/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
  * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/

#ifndef ROODALITZAMPLITUDE
#define ROODALITZAMPLITUDE

#define MYRN 16
#define MYZN 2

#include "RooAbsPdf.h"
#include "RooRealProxy.h"
#include "RooListProxy.h"
#include "RooCategoryProxy.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include "TList.h"
#include "TComplex.h"
#include "TString.h"
#include "TChain.h"
#include "RooDataSet.h"
#include "RooTDalitz/EvtCGCoefSingle.hh"
#include <memory>

class Jpsihh_dlz {
public:
  double mkp;
  double mjpsip;
  double theta;
  double theta1;
  double theta2;
//  double phi;
  double phi1;
  double phi2;
  double phiZ;
  double phiMu;
  double phiPsi;
  double alphaMu;
  double thetaB;
  double thetaPsi;
  double thetaZ;
  double thetap;
  double w;
  bool defed[MYRN+MYZN];
  //bool defedZ[1];
  Float_t ARe[MYRN][2][2][2][6];
  Float_t AIm[MYRN][2][2][2][6];
  Float_t AZRe[MYZN][2][2][2][12];
  Float_t AZIm[MYZN][2][2][2][12];
  Jpsihh_dlz() {}
//  virtual ~Jpsihh_dlz() {}

private:
//   ClassDef(Jpsihh_dlz, 1);
};


 
class RooDalitzAmplitude : public RooAbsPdf {
public:
  RooDalitzAmplitude():  CG1(1,2),  CG3(3,2),  CG5(5,2),  CG7(7,2),  CG9(9,2),
  CG21(2,1),  CG41(4,1),  CG03(0,3),  CG23(2,3),  CG43(4,3),  CG63(6,3) {} ; 
  RooDalitzAmplitude(const char *name, const char *title,
		     RooArgList& values, TList*, TList*, const TString MCdata, RooDataSet&, bool isPP=true, bool isCach=true);
  RooDalitzAmplitude(const RooDalitzAmplitude& other, const char* name=0) ;
  virtual TObject* clone(const char* newname) const { return new RooDalitzAmplitude(*this,newname); }
  virtual ~RooDalitzAmplitude() { 
//    if(PDLZ) {
//      PDLZ->clear();
//      delete PDLZ;
//      std::cout << "cleared PDLZ" << std::endl;
//    }//PDLZ->clear();
/*    while(!pdlz.empty()) {
        delete &(pdlz.back());
        pdlz.pop_back();
    }
*/
//    if(pdlz) {
//      pdlz->clear();
//      delete pdlz;//
//      std::cout << "cleared pdlz " << std::endl;
//    }
//    delete _resList;
//    delete _resListZ;
//    std::cout << "capacity " << PDLZ.capacity() << " " << pdlz.capacity() << std::endl;
//    PDLZ.resize(0);
//    pdlz.resize(0);
//    delete _resParCache;
//   delete PDLZ;
//    delete pdlz;
//    delete AA;
//    delete AAZ;
//    delete ABZ;
//    free(AA);
//    free(AAZ);
//    free(ABZ);
//    free(amp);
//    free(ampZ);
  }

  Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=0) const ;
  Double_t analyticalIntegral(Int_t code, const char* rangeName=0) const ;

  Int_t getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t staticInitOK=kTRUE) const;
  void initGenerator(Int_t code) {} ; // optional pre-generation initialization
  void generateEvent(Int_t code);

  TComplex MEang(double, double, int, double, double, int, Jpsihh_dlz&) const;
  TComplex MEangZ(double, double, int, double, double, int, double, Jpsihh_dlz&) const;
  Double_t GetAmp2s(Jpsihh_dlz&, int print=0) const;
  Double_t GetAmp2sForInt(Jpsihh_dlz&, int, int group=0) const;  
  void getInt(double *vint, double ylo=0, double yhi=5) const;
  void getIFandFF() const;  
  TComplex HelicityCoff(RooArgList ires, Int_t ihel) const;
  TComplex PartWaveCoff(RooArgList ires, Int_t, Int_t, Int_t) const;
  TComplex PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const;
  Double_t BTerm(Double_t Spin, Double_t mpp, Double_t mr) const;
  Double_t BTermZ(Double_t Spin, Double_t mpp, Double_t mr) const;
  void breit_wigner(double m, double gamma, double e2, double &r_ampl, double &i_ampl) const;
  Double_t F_BW(double r, int L, double p, double p0) const;
  bool BW_AMP(double m_r, double gamma_r, double mpp, int LR,
	      double &ampl_r, double &ampl_i) const;
  bool BW_AMPZ(double m_r, double gamma_r, double mpp, int LR,
	      double &ampl_r, double &ampl_i) const;
  Double_t getp(double, double, double ) const;
  Double_t getphsp(double mX) const;
  void filldlz(Jpsihh_dlz &dlz, Double_t xmkp, Double_t ,
	       Double_t xcostheta1, Double_t xcostheta2,
	       Double_t xphi1, Double_t xphi2, 
	       Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t, Double_t,
	       Double_t xjpsip = 0.0, Double_t w = 1.0) const;
  Bool_t kine_limits(double mpp) const;
  Bool_t kine_limitsZ(double mpp) const;  
  void genToy(const char*, bool verbose = false) const;
  void genToyNoACC(const char*) const;  
  void ResetDef(int ir) const;
  Double_t IntegralMethod1() const;
  void CalCoupling() const;
  bool checkchange() const;

  virtual RooAbsReal* createSUM(RooAbsData& data, const RooLinkedList& cmdList) ;
  virtual RooAbsReal* createSUM(RooAbsData& data, const RooCmdArg& arg1=RooCmdArg::none(),  const RooCmdArg& arg2=RooCmdArg::none(),  
				const RooCmdArg& arg3=RooCmdArg::none(),  const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),  
				const RooCmdArg& arg6=RooCmdArg::none(),  const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;

  Double_t evaluate(Double_t* );  
  //  Double_t getp(double );

protected:

  RooListProxy _values ;
  TList *_resList;
  TList *_resListZ;
  RooListProxy resParams;
  bool _isPP;  
  bool _isCach;
  
  mutable EvtCGCoefSingle CG1;
  mutable EvtCGCoefSingle CG3;
  mutable EvtCGCoefSingle CG5;
  mutable EvtCGCoefSingle CG7;
  mutable EvtCGCoefSingle CG9;
  mutable EvtCGCoefSingle CG21;
  mutable EvtCGCoefSingle CG41;
  mutable EvtCGCoefSingle CG03;
  mutable EvtCGCoefSingle CG23;
  mutable EvtCGCoefSingle CG43;
  mutable EvtCGCoefSingle CG63;
  mutable TComplex AA[2][2][2][MYRN][MYRN][6][6];
  mutable TComplex AAZ[2][2][2][MYZN][MYZN][12][12];
  mutable TComplex ABZ[2][2][2][MYZN][MYRN][12][6];  
//  mutable TComplex amp[MYRN][2][2][2][6];
//  mutable TComplex ampZ[MYZN][2][2][2][12];
  
  Double_t* _resParCache;
//  mutable std::vector<Jpsihh_dlz> pdlz;
//  mutable std::vector<Jpsihh_dlz> PDLZ;  

  //std::vector<Jpsihh_dlz> *pdlz;
  //std::vector<Jpsihh_dlz> *PDLZ;    
  std::shared_ptr<std::vector<Jpsihh_dlz> > pdlz;
  std::shared_ptr<std::vector<Jpsihh_dlz> > PDLZ;  
  //const TString MCDATA;
  //TChain* smcdata;

  Double_t evaluate() const ;

  Int_t NR;
  Int_t NZ;  
  double sumW;
  double m_lb;
  double m_k;
  double m_p;
  double m_jpsi;

private:

  // ClassDef(RooDalitzAmplitude,1) // Your description goes here...
};
 
#endif
