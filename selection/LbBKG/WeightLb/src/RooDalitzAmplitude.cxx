/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 
#include "RooTDalitz/RooDalitzAmplitude.h"
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 
#include "TMatrixD.h"
#include "TIterator.h"
#include "RooRandom.h"
#include "TTree.h"
#include "TFile.h"
#include "RooFit.h"
#include "RooMsgService.h" 
#include "TClass.h"
#include "Riostream.h"
#include "TObjString.h"
#include "TPaveText.h"
#include "TList.h"
#include "TH1.h"
#include "TH2.h"
#include "TMatrixD.h"
#include "TMatrixDSym.h"
#include "RooAbsPdf.h"
#include "RooDataSet.h"
#include "RooArgSet.h"
#include "RooArgProxy.h"
#include "RooRealProxy.h"
#include "RooRealVar.h"
#include "RooGenContext.h"
#include "RooBinnedGenContext.h"
#include "RooPlot.h"
#include "RooCurve.h"
#include "RooNLLVar.h"
#include "RooTDalitz/RooSUMVar.h"
#include "RooMinuit.h"
#include "RooCategory.h"
#include "RooNameReg.h"
#include "RooCmdConfig.h"
#include "RooGlobalFunc.h"
#include "RooAddition.h"
#include "RooRandom.h"
#include "RooNumIntConfig.h"
#include "RooProjectedPdf.h"
#include "RooInt.h"
#include "RooCustomizer.h"
#include "RooConstraintSum.h"
#include "RooParamBinning.h"
#include "RooNumCdf.h"
#include "RooFitResult.h"
#include "RooNumGenConfig.h"
#include "RooCachedReal.h"
#include "RooXYChi2Var.h"
#include "RooChi2Var.h"
#include "RooMinimizer.h"
#include "RooRealIntegral.h"
#include "Math/CholeskyDecomp.h"
#include <string>

#define PAW

//For integration
//TComplex AA[2][2][2][MYRN][MYRN][6][6];
//TComplex AAZ[2][2][2][MYZN][MYZN][12][12];
//TComplex ABZ[2][2][2][MYZN][MYRN][12][6];
TComplex amp[MYRN][2][2][2][6];
TComplex ampZ[MYZN][2][2][2][12];
//Double_t sumW;

//ClassImp(RooDalitzAmplitude) 

//CG (1,1,L,S,0,1) S=1,3,5,7,9,11, L= S-1, S+1
Double_t C2[6][2] = {
1.0000000000000000e+00,
-5.7735026918962584e-01,
-5.7735026918962573e-01,
4.4721359549995765e-01,
4.4721359549995754e-01,
-3.7796447300922748e-01,
-3.7796447300922759e-01,
3.3333333333333659e-01,
3.3333333333332898e-01,
-3.0151134457775197e-01,
-3.0151134457772666e-01,
2.7735009811269257e-01};


//ClassImp(RooDalitzAmplitude) 

Int_t Hel1Two[] = {1,1,-1,-1,3,-3};
Int_t Hel2[] = {1,0,0,-1,1,-1};
Double_t _FFR(3.0);
Double_t _FFB(3.0);
RooDalitzAmplitude::RooDalitzAmplitude(const char *name, 
				       const char *title, 
				       RooArgList& values,
				       TList* resList,
				       TList* resListZ,
				       const TString mcdata,
				       RooDataSet &data,
				       bool isPP,
				       bool isCach) :
  RooAbsPdf(name,title), 
  _values("values","values",this),
  _resList(resList),
  _resListZ(resListZ),
  resParams("resParams", "Parameters for resonaces", this),
  _isPP(isPP),
  _isCach(isCach),
  CG1(1,2),
  CG3(3,2),
  CG5(5,2),
  CG7(7,2),
  CG9(9,2),
  CG21(2,1),
  CG41(4,1),
  CG03(0,3),
  CG23(2,3),
  CG43(4,3),
  CG63(6,3)
  // MCDATA(mcdata)
{ 

  //TChain  //TChain
  char cname[20];
  char swname[20];
  sprintf(cname,"h1");
  sprintf(swname,"sw");
  int mcflat(0);
  if(mcdata.Contains("MCFlatAcc")) {
    sprintf(cname,"MyTuple");
    sprintf(swname,"nsig_sw");
    mcflat = 1;
  }

  TChain *smcdata = new TChain(cname);
  smcdata->Add(mcdata);

  m_lb = 5.6195;
  m_k = 0.493677;
  m_p = 0.938272046;
  m_jpsi = 3.096916;
  TIterator* coefIter1 = values.createIterator();
  RooAbsArg* coef;
  
  while( (coef = (RooAbsArg*)coefIter1->Next()) ){
    if( !dynamic_cast<RooAbsReal*>(coef) ){
      assert(0);
    }
    _values.add(*coef);
  }

  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    //for (int i=0; i<nres; i++) {
    //RooDalitzResonance *res = (RooDalitzResonance*)_resList->At( ires );
    
    //     RooArgList *ires = (RooArgList*)_resList->At( i );
    RooArgList ires = (*Ires);
    resParams.add(ires[0]);
    resParams.add(ires[1]);
    resParams.add(ires[2]);
    resParams.add(ires[3]);
    resParams.add(ires[4]);
    resParams.add(ires[5]);
    resParams.add(ires[6]);
    resParams.add(ires[7]);
    resParams.add(ires[8]);
    resParams.add(ires[9]);
    resParams.add(ires[10]);
    resParams.add(ires[11]);
    resParams.add(ires[12]);
    resParams.add(ires[13]);
  }

  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    //for (int i=0; i<nres; i++) {
    //RooDalitzResonance *res = (RooDalitzResonance*)_resList->At( ires );
    
    //     RooArgList *ires = (RooArgList*)_resList->At( i );
    RooArgList ires = (*Ires);
    resParams.add(ires[0]);
    resParams.add(ires[1]);
    resParams.add(ires[2]);
    resParams.add(ires[3]);
    resParams.add(ires[4]);
    resParams.add(ires[5]);
    resParams.add(ires[6]);
    resParams.add(ires[7]);
    resParams.add(ires[8]);
    resParams.add(ires[9]);    
  }

  NR = _resList->GetSize();
  NZ = _resListZ->GetSize();
  int nres = NR+NZ;
  std::cout << "Number of Resonances " << nres << std::endl;
  //each set to 2 parms.
  int ncached = 2*nres;
  _resParCache = new Double_t[ncached];
  for (int i=0; i<ncached; i++) _resParCache[i]=0;

  assert(nres<=MYRN+MYZN);

  double costheta, costheta1,costheta2,phi1,phi2;
  double mkp,sw, mjpsip;
  double phiZ;
  double phiMu;
  double phiPsi;
  double alphaMu;
  double costhetaB;
  double costhetaPsi;
  double costhetaZ;
  double costhetap;

  smcdata->SetBranchAddress("mkp", &mkp);
  smcdata->SetBranchAddress("mjpsip", &mjpsip);
  smcdata->SetBranchAddress("cosTheta_Lb", &costheta);
  smcdata->SetBranchAddress("cosTheta_L", &costheta1);
  smcdata->SetBranchAddress("cosTheta_Jpsi", &costheta2);
//  
  smcdata->SetBranchAddress("phiK", &phi1);
  smcdata->SetBranchAddress("phiMu", &phi2);
  smcdata->SetBranchAddress("Z_cosTheta_Lb", &costhetaB);
  smcdata->SetBranchAddress("Z_cosTheta_Z", &costhetaZ);
  smcdata->SetBranchAddress("Z_cosTheta_Jpsi", &costhetaPsi);
  smcdata->SetBranchAddress("Z_phiZ", &phiZ);
  smcdata->SetBranchAddress("Z_phiJpsi", &phiPsi);
  smcdata->SetBranchAddress("Z_phiMu", &phiMu);
  smcdata->SetBranchAddress("cosTheta_p", &costhetap);
  smcdata->SetBranchAddress("alpha_Mu", &alphaMu);
  smcdata->SetBranchAddress(swname, &sw);
  
  int smcnum = smcdata->GetEntries();
  if(mcflat==1) smcnum = 1000;
  sumW = 0.0;
//  pdlz->reserve(smcnum);
//  pdlz = new std::vector<Jpsihh_dlz>();
//  PDLZ = new std::vector<Jpsihh_dlz>();
  pdlz = std::make_shared<std::vector<Jpsihh_dlz>>();
  PDLZ = std::make_shared<std::vector<Jpsihh_dlz>>();  
  for(int imc=0; imc<smcnum; imc++) {
    smcdata->GetEntry(imc);
    //mkp>2GeV
    if(!kine_limits(mkp)) continue;
   if(!kine_limitsZ(mjpsip)) continue;
    Jpsihh_dlz xdlz;// = new Jpsihh_dlz();
    filldlz(xdlz, mkp, costheta, costheta1, costheta2, phi1, phi2,
	    costhetaB,costhetaZ,costhetaPsi,phiZ,phiPsi,phiMu,costhetap,alphaMu,
	    mjpsip,
	    sw);
    sumW += sw;
    pdlz->push_back(xdlz);
  }
  
  std::cout << "INT MC size " << pdlz->size() << " " << pdlz->capacity() << std::endl;
  
  delete coefIter;
  delete coefIterZ;
  delete coefIter1;
  RooArgSet *row;  
  smcnum = data.numEntries();
//  PDLZ->reserve(smcnum);
  if(_isCach) {
  for(int i=0; i<smcnum; ++i) {
    row = (RooArgSet *)data.get(i);
    Jpsihh_dlz xdlz;// = new Jpsihh_dlz();
    //row->Print("V");
    mkp = ((RooAbsReal*)row->find("mkp"))->getVal();
    // if(!kine_limits(mkp)) { std::cout << "why " << std::endl;}
    
    costheta =  ((RooAbsReal*)row->find("cosTheta_Lb"))->getVal();
    costheta1 = ((RooAbsReal*)row->find("cosTheta_L"))->getVal();
    costheta2 = ((RooAbsReal*)row->find("cosTheta_Jpsi"))->getVal();
    phi1 = ((RooAbsReal*)row->find("phiK"))->getVal();
    phi2 = ((RooAbsReal*)row->find("phiMu"))->getVal();
    costhetaB = ((RooAbsReal*)row->find("Z_cosTheta_Lb"))->getVal();
    costhetaZ = ((RooAbsReal*)row->find("Z_cosTheta_Z"))->getVal();
    costhetaPsi = ((RooAbsReal*)row->find("Z_cosTheta_Jpsi"))->getVal();
    phiZ = ((RooAbsReal*)row->find("Z_phiZ"))->getVal();
    phiPsi = ((RooAbsReal*)row->find("Z_phiJpsi"))->getVal();
    phiMu = ((RooAbsReal*)row->find("Z_phiMu"))->getVal();
    costhetap = ((RooAbsReal*)row->find("cosTheta_p"))->getVal();
    alphaMu = ((RooAbsReal*)row->find("alpha_Mu"))->getVal();
    mjpsip = ((RooAbsReal*)row->find("mjpsip"))->getVal();
//    std::cout << i << " " << ((RooAbsReal*)row->find("index"))->getVal() << std::endl;
    //if(!kine_limitsZ(mjpsip) ) {std::cout << "why mjpsip" << std::endl;}
    //   double phi =  ((RooAbsReal&)row[6]).getVal();
//    std::cout << "to fill " << std::endl;
    filldlz(xdlz, mkp, costheta, costheta1, costheta2, phi1, phi2,
	    costhetaB,costhetaZ,costhetaPsi,phiZ,phiPsi,phiMu,costhetap,alphaMu,
	    mjpsip);
    PDLZ->push_back(xdlz);
  }
  } else {
    PDLZ->reserve(0);
  }
  std::cout << "Data size " << PDLZ->size() << " " << PDLZ->capacity() << std::endl;
  smcdata->Delete();
//  delete row;
  analyticalIntegral(7);
  //  IntegralMethod1();  
} 


RooDalitzAmplitude::RooDalitzAmplitude(const RooDalitzAmplitude& other, const char* name) :  
  RooAbsPdf(other,name), 
  _values("values",this,other._values),
  _resList(other._resList),
  _resListZ(other._resListZ),
  resParams("resParams", this, other.resParams),
  _isPP(other._isPP), _isCach(other._isCach),
  CG1(other.CG1),
  CG3(other.CG3),
  CG5(other.CG5),
  CG7(other.CG7),
  CG9(other.CG9),
  CG21(other.CG21),
  CG41(other.CG41),
  CG03(other.CG03),
  CG23(other.CG23),
  CG43(other.CG43),
  CG63(other.CG63),
  AA(other.AA),
  AAZ(other.AAZ),
  ABZ(other.ABZ),
//  amp(other.amp),
//  ampZ(other.ampZ),
  pdlz(other.pdlz),
  PDLZ(other.PDLZ),
  NR(other.NR), NZ(other.NZ),
  sumW(other.sumW),
  m_lb(other.m_lb), m_k(other.m_k),
  m_p(other.m_p), m_jpsi(other.m_jpsi)    
 { 
  int n= pdlz->size();
  std::cout << "new pdlz size " << n << std::endl;
//  pdlz = other.pdlz;
//  PDLZ = other.PDLZ;
   
     //TChain
   //smcdata = new TChain("mctree");
   // smcdata->Add(MCDATA);
   _resParCache = other._resParCache;
 } 



Bool_t RooDalitzAmplitude::kine_limits(double mpp) const
{
  if(mpp<m_k+m_p) return false;
  if(mpp>m_lb-m_jpsi) return false;
  return true;
}

Bool_t RooDalitzAmplitude::kine_limitsZ(double mjpsip) const
{
   if((mjpsip<m_jpsi+m_p) || (m_lb<mjpsip+m_k) ) return false;
   return true;
}

Double_t RooDalitzAmplitude::evaluate(Double_t* Values) 
{

  Jpsihh_dlz *xdlz1 = new Jpsihh_dlz();
  double mkp = Values[0];
  if(!kine_limits(mkp)) { std::cout << "why mkp " << mkp << " " << std::endl;return 0.0;}
  
  double costheta =  Values[1];
  double costheta1 = Values[2];
  double costheta2 = Values[3];
  double phi1 = Values[4];
  double phi2 = Values[5];
  double costhetaB = Values[6];
  double costhetaZ = Values[7];
  double costhetaPsi = Values[8];
  double phiZ = Values[9];
  double phiPsi = Values[10];
  double phiMu = Values[11];
  double costhetap = Values[12];
  double alphaMu = Values[13];
  double mjpsip = Values[14];
  if(!kine_limitsZ(mjpsip) ) {std::cout << "why mjpsip " << mjpsip << std::endl;return 0.0;}
  //   double phi =  ((RooAbsReal&)Values[6];
  filldlz(*xdlz1, mkp, costheta, costheta1, costheta2, phi1, phi2,
	  costhetaB,costhetaZ,costhetaPsi,phiZ,phiPsi,phiMu,costhetap,alphaMu,
	  mjpsip);
  //   std::cout << "test1 " <<xdlz1.defed << std::endl;
  double TA =  GetAmp2s(*xdlz1);
  delete xdlz1;
  return TA/0.08664880474091117557;
}

Double_t RooDalitzAmplitude::evaluate() const 
{ 

  int  index = (int)((RooAbsReal&)_values[_values.getSize()-1]).getVal();
  double inttt(-1);
  if(_norm) inttt = _norm->getVal();
//  std::cout << "zhanglm int of index " << index << " " << inttt << std::endl;
//  if(index==0) std::cout << "index " << std::endl;
  double TA1(0);
  if(_isCach&&index<PDLZ->size()) {
    Jpsihh_dlz &p = (*PDLZ)[index];
    double mkp = p.mkp;
    double mjpsip = p.mjpsip;    
    double mkp1 = ((RooAbsReal&)_values[0]).getVal();
    double mjpsip1 = ((RooAbsReal&)_values[14]).getVal();
    if(fabs(mkp-mkp1)<1e-20 && fabs(mjpsip1-mjpsip)<1e-20) {
      if(!kine_limits(mkp)) { std::cout << "why " << std::endl;return 0.0;}
      if(!kine_limitsZ(mjpsip) ) {std::cout << "why mjpsip" << std::endl;return 0.0;}
      TA1 =  GetAmp2s(p,1);
//  std::cout << "lzhang evaluate() for index " << index << std::endl;      
      return TA1;
    }
  }
//  std::cout << " no match " << std::endl;
  Jpsihh_dlz *xdlz1 = new Jpsihh_dlz();
  double mkp = ((RooAbsReal&)_values[0]).getVal();
  if(!kine_limits(mkp)) { std::cout << "why " << std::endl;return 0.0;}
  
  double costheta =  ((RooAbsReal&)_values[1]).getVal();
  double costheta1 = ((RooAbsReal&)_values[2]).getVal();
  double costheta2 = ((RooAbsReal&)_values[3]).getVal();
  double phi1 = ((RooAbsReal&)_values[4]).getVal();
  double phi2 = ((RooAbsReal&)_values[5]).getVal();
  double costhetaB = ((RooAbsReal&)_values[6]).getVal();
  double costhetaZ = ((RooAbsReal&)_values[7]).getVal();
  double costhetaPsi = ((RooAbsReal&)_values[8]).getVal();
  double phiZ = ((RooAbsReal&)_values[9]).getVal();
  double phiPsi = ((RooAbsReal&)_values[10]).getVal();
  double phiMu = ((RooAbsReal&)_values[11]).getVal();
  double costhetap = ((RooAbsReal&)_values[12]).getVal();
  double alphaMu = ((RooAbsReal&)_values[13]).getVal();
  double mjpsip = ((RooAbsReal&)_values[14]).getVal();
  if(!kine_limitsZ(mjpsip) ) {std::cout << "why mjpsip" << std::endl;return 0.0;}
  //   double phi =  ((RooAbsReal&)_values[6]).getVal();
  filldlz(*xdlz1, mkp, costheta, costheta1, costheta2, phi1, phi2,
	  costhetaB,costhetaZ,costhetaPsi,phiZ,phiPsi,phiMu,costhetap,alphaMu,
	  mjpsip);
  //   std::cout << "test1 " <<xdlz1.defed << std::endl;
  double TA =  GetAmp2s(*xdlz1);
//   std::cout << "test2 " << TA << " "<< TA1 << std::endl;
  delete xdlz1;

  return TA;
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
  //   return 1.0 ; 
} 


void RooDalitzAmplitude::genToy(const char *name, bool verbose) const 
{ 
//  char filename[100];
//  sprintf("toy%s.root",name);
  CalCoupling();   
  TFile *file = new TFile(TString::Format("toy%s.root",name).Data(),"recreate");
  TTree *tree = new TTree("tree","toy");
  double costheta, costheta1,costheta2,phi1,phi2,phi;
  double mkp,sw,w;
  double wl[MYRN+1], wz[MYZN+1];
  double mjpsip;
  double phiZ;
  double phiMu;
  double phiPsi;
  double alphaMu;
  double costhetaB;
  double costhetaPsi;
  double costhetaZ;
  double costhetap;
  tree->Branch("mkp", &mkp, "mkp/D");
  tree->Branch("mjpsip", &mjpsip, "mjpsip/D");  
  tree->Branch("costheta", &costheta, "costheta/D");
  tree->Branch("costheta1", &costheta1, "costheta1/D");
  tree->Branch("costheta2", &costheta2, "costheta2/D");
//  tree->Branch("phi", &phi, "phi/D");
  tree->Branch("phi1", &phi1, "phi1/D");
  tree->Branch("phi2", &phi2, "phi2/D");
  tree->Branch("Z_cosTheta_Lb", &costhetaB, "Z_cosTheta_Lb/D");
  tree->Branch("Z_cosTheta_Z", &costhetaZ, "Z_cosTheta_Z/D");
  tree->Branch("Z_cosTheta_Jpsi", &costhetaPsi, "Z_cosTheta_Jpsi/D");
  tree->Branch("Z_phiZ", &phiZ, "Z_phiZ/D");
  tree->Branch("Z_phiJpsi", &phiPsi, "Z_phiJpsi/D" );
  tree->Branch("Z_phiMu", &phiMu, "Z_phiMu/D");
  tree->Branch("cosTheta_p", &costhetap, "cosTheta_p/D" );
  tree->Branch("alpha_Mu", &alphaMu, "alpha_Mu/D");
  tree->Branch("w", &w, "w/D");
  tree->Branch("wL", &wl[0], "wL/D");
  tree->Branch("wZ", &wz[0], "wZ/D");
  if(verbose) {
    for(int ii=0; ii<NR; ++ii) 
      tree->Branch(TString("w")+TString((_resList->At(ii))->GetName()), &wl[ii+1], TString("w")+TString((_resList->At(ii))->GetName())+TString("/D"));
    for(int ii=0; ii<NZ; ++ii) 
      tree->Branch(TString("w")+TString((_resListZ->At(ii))->GetName()), &wz[ii+1], TString("w")+TString((_resListZ->At(ii))->GetName())+TString("/D"));   
  }
  int smcnum = pdlz->size();//smcdata->GetEntries();
  double inte(0.);
  for(int i=0; i<smcnum; i++) {
    
    //mkp>2GeV
    //if(mkp<2.0) continue;
    Jpsihh_dlz &p = (*pdlz)[i];
    
    //    filldlz(p, mkp, costheta, costheta1, costheta2, phi1, phi2, phi);
    double val =  GetAmp2s(p,1);    
    mkp = p.mkp; 
    mjpsip = p.mjpsip;
    costheta = cos(p.theta);
    costheta1 = cos(p.theta1);
    costheta2 = cos(p.theta2);
    phi1 = p.phi1;
    phi2 = p.phi2;
    phiZ = p.phiZ;
    phiMu = p.phiMu;
    phiPsi = p.phiPsi;
    alphaMu = p.alphaMu;
    costhetaB = cos(p.thetaB);
    costhetaPsi = cos(p.thetaPsi);
    costhetaZ = cos(p.thetaZ);
    costhetap = cos(p.thetap);
    //  dlz.phi = xphi;
    
    double sweight = p.w;
    w= val*sweight;
    //calculcate each wi
    wl[0] = GetAmp2sForInt(p,-1,1) * sweight;
    wz[0] = GetAmp2sForInt(p,-1,2) * sweight;
    if(verbose) {    
      for(int ii=0; ii<NR; ++ii) 
        wl[ii+1] = GetAmp2sForInt(p,ii) * sweight;
      for(int ii=0; ii<NZ; ++ii) 
        wz[ii+1] = GetAmp2sForInt(p,ii+NR) * sweight;
    }
    tree->Fill();
  }
  tree->Write();
  file->Close();
  
}

void RooDalitzAmplitude::genToyNoACC(const char *name) const 
{ 
//  char filename[100];
//  sprintf("toy%s.root",name);

/*  TFile *file = new TFile(TString::Format("toynoacc%s.root",name).Data(),"recreate");
  TTree *tree = new TTree("tree","toy");
  double costheta, costheta1,costheta2,phi1,phi2,phi;
  double mkp,sw,w;
  double mjpsip;
  tree->Branch("mkp", &mkp, "mkp/D");
//  tree->Branch("mjpsip", &mjpsip, "mjpsip/D");  
  tree->Branch("costheta", &costheta, "costheta/D");
  tree->Branch("costheta1", &costheta1, "costheta1/D");
  tree->Branch("costheta2", &costheta2, "costheta2/D");
//  tree->Branch("phi", &phi, "phi/D");
  tree->Branch("phi1", &phi1, "phi1/D");
  tree->Branch("phi2", &phi2, "phi2/D");
  tree->Branch("w", &w, "w/D");



  double vrnd[6];
  double mmin = m_k+m_p;
  double mmax = m_lb-m_jpsi;

  for(int i=0; i<1e6; ++i) {
    if(i%1000==0) std::cout <<"Generate .... " << i << std::endl;
    RooRandom::uniform(6, vrnd);
    //   if(!kine_limits(mkp)) return 0.0;
    costheta = (1.+1.)*vrnd[0]-1.; 
    costheta1 = (1.+1.)*vrnd[1]-1.; 
    costheta2 = (1.+1.)*vrnd[2]-1.; 
    phi1 = ((1.+1.)*vrnd[3]-1.)*TMath::Pi(); 
    phi2 = ((1.+1.)*vrnd[4]-1.)*TMath::Pi(); 
//    phi =  ((1.+1.)*vrnd[5]-1.)*TMath::Pi(); 
    mkp = (mmax-mmin)*vrnd[5]+mmin;
    Jpsihh_dlz *xdlz = new Jpsihh_dlz();

    filldlz(*xdlz, mkp, costheta, costheta1, costheta2, phi1, phi2);
    w =  GetAmp2s(*xdlz)*getp(m_lb, m_jpsi, mkp)*getp(mkp, m_p, m_k);
    tree->Fill();
    delete xdlz;
  }
  
  tree->Write();
  file->Close();
*/  
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   //   return 1.0 ; 
 } 


 Int_t RooDalitzAmplitude::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars,analVars,x)) return 1 ; 
  std::cout<<"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"<<std::endl;
   std::cout<<"Requested integration over these variables: "<<std::endl;
   allVars.Print("V");
   std::cout<<"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"<<std::endl<<std::endl;
   /* 
   RooArgSet List;
   List.add();
   List.add();
   List.add();
   List.add();
   List.add();
   List.add();
   List.add();
   */
   if( matchArgs(allVars, analVars, _values) ) 
  
   return 7;
   return 0 ; 
 } 


Double_t RooDalitzAmplitude::IntegralMethod1() const
{

  int smcnum = pdlz->size();//smcdata->GetEntries();
  std::cout << "MC inte size " << smcnum << std::endl;
  double inte(0.);
//  sumW = 0.;
  for(int i=0; i<smcnum; i++) {
    //mkp>2GeV
    //if(mkp<2.0) continue;
    Jpsihh_dlz &p = (*pdlz)[i];
    double sweight = p.w;
//    sumW += sweight;
    //    filldlz(p, mkp, costheta, costheta1, costheta2, phi1, phi2, phi);
    double val =  GetAmp2s(p,1);    

    inte += val*sweight;
  }
  inte = inte/sumW;
//  std::cout.precision(10);
  std::cout << "Integration1, " << inte << std::endl;  
  
//  printf("Integration1, %10.6f\n",inte);
//  int smcnum = pdlz->size();//smcdata->GetEntries();

  //sum over MC
  TComplex tctmp;
  for(int i=0;i<2; ++i) {
    for(int j=0; j<2; ++j) {
      for(int k=0; k<2; ++k) {
	for(int ir1=0; ir1<NR; ++ir1) {
	  for(int ir2=0; ir2<NR; ++ir2) { 
	    for(int m1=0; m1<6; ++m1) {
	      for(int m2=0; m2<6; ++m2) {
		AA[i][j][k][ir1][ir2][m1][m2]=TComplex(0.,0.);
	      }
	    }
	  }
	}
      }
    }
  }
//  std::cout << "Step 1 " << std::endl;
 for(int imc=0; imc<smcnum; imc++) {
   Jpsihh_dlz &p = (*pdlz)[imc];  
   double sweight = p.w;
    //if(mkp<2.0) continue;
   
   for(int i=0;i<2; ++i) {
     for(int j=0; j<2; ++j) {
       for(int k=0; k<2; ++k) { 
	 for(int ir1=0; ir1<NR; ++ir1) {
	   for(int m1=0; m1<6; ++m1) {
	     TComplex tp1 = TComplex(p.ARe[ir1][i][j][k][m1],-p.AIm[ir1][i][j][k][m1]);
	     for(int ir2=0; ir2<NR; ++ir2) {
	       for(int m2=0; m2<6; ++m2) {
		 TComplex tp2 = TComplex(p.ARe[ir2][i][j][k][m2],p.AIm[ir2][i][j][k][m2]);
		 tctmp =  tp1*tp2;
		 AA[i][j][k][ir1][ir2][m1][m2] += tctmp*sweight;
	       }
	     }
	   }
	 }
       }
     }
   }
 }

  //sum over MC for Z
//  TComplex tctmp;
  for(int i=0;i<2; ++i) {
    for(int j=0; j<2; ++j) {
      for(int k=0; k<2; ++k) {
	for(int ir1=0; ir1<NZ; ++ir1) {
	  for(int ir2=0; ir2<NZ; ++ir2) { 
	    for(int m1=0; m1<12; ++m1) {
	      for(int m2=0; m2<12; ++m2) {
		AAZ[i][j][k][ir1][ir2][m1][m2]=TComplex(0.,0.);
	      }
	    }
	  }
	}
      }
    }
  }
//  std::cout << "Step 1 " << std::endl;
 for(int imc=0; imc<smcnum; imc++) {
   Jpsihh_dlz &p = (*pdlz)[imc];  
   double sweight = p.w;
    //mkp>2GeV
    //if(mkp<2.0) continue;
   
   for(int i=0;i<2; ++i) {
     for(int j=0; j<2; ++j) {
       for(int k=0; k<2; ++k) { 
	 for(int ir1=0; ir1<NZ; ++ir1) {
	   for(int m1=0; m1<12; ++m1) {
	     TComplex tp1 = TComplex(p.AZRe[ir1][i][j][k][m1],-p.AZIm[ir1][i][j][k][m1]);
	     for(int ir2=0; ir2<NZ; ++ir2) {
	       for(int m2=0; m2<12; ++m2) {
		 TComplex tp2 = TComplex(p.AZRe[ir2][i][j][k][m2],p.AZIm[ir2][i][j][k][m2]);
		 tctmp =  tp1*tp2;
		 AAZ[i][j][k][ir1][ir2][m1][m2] += tctmp*sweight;
	       }
	     }
	   }
	 }
       }
     }
   }
 }

  for(int i=0;i<2; ++i) {
    for(int j=0; j<2; ++j) {
      for(int k=0; k<2; ++k) {
	for(int ir1=0; ir1<NZ; ++ir1) {
	  for(int ir2=0; ir2<NR; ++ir2) { 
	    for(int m1=0; m1<12; ++m1) {
	      for(int m2=0; m2<6; ++m2) {
		ABZ[i][j][k][ir1][ir2][m1][m2]=TComplex(0.,0.);
	      }
	    }
	  }
	}
      }
    }
  }
//  std::cout << "Step 1 " << std::endl;
 for(int imc=0; imc<smcnum; imc++) {
   Jpsihh_dlz &p = (*pdlz)[imc];  
   double sweight = p.w;
    //mkp>2GeV
    //if(mkp<2.0) continue;
   
   for(int i=0;i<2; ++i) {
     for(int j=0; j<2; ++j) {
       for(int k=0; k<2; ++k) { 
	 for(int ir1=0; ir1<NZ; ++ir1) {
	   for(int m1=0; m1<12; ++m1) {
	     TComplex tp1 = TComplex(p.AZRe[ir1][i][j][k][m1],-p.AZIm[ir1][i][j][k][m1]);
	     for(int ir2=0; ir2<NR; ++ir2) {
	       for(int m2=0; m2<6; ++m2) {
		 TComplex tp2 = TComplex(p.ARe[ir2][i][j][k][m2],p.AIm[ir2][i][j][k][m2]);
		 tctmp =  tp1*tp2;
		 ABZ[i][j][k][ir1][ir2][m1][m2] += tctmp*sweight;
	       }
	     }
	   }
	 }
       }
     }
   }
 }
 return inte; 
}

Double_t RooDalitzAmplitude::analyticalIntegral(Int_t code, const char* rangeName) const  
{ 
  
  // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
  // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
  // BOUNDARIES FOR EACH OBSERVABLE x
  
  // assert(code==1) ; 
  // return (x.max(rangeName)-x.min(rangeName)) ; 
  
  switch(code) {
  case 7:
    break;
  default: assert(0);
  }
  //  return 1.0;
  
  //  double costheta, costheta1,costheta2,phi1,phi2,phi;
  //double mkp,sw;
  // std::cout << "zhanglm Integral " << std::endl;
  //if parameters are updated, recache it.
  Double_t Inte = 0;  
  CalCoupling();   
  
  if(!_isPP) {
    if(checkchange())   {
      Inte = IntegralMethod1();
    } else {
    
      TComplex a1,a2;
      for(int i=0;i<=1; ++i) {//del
	for(int j=0; j<=1; ++j) { //hel0
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int ir1=0; ir1<NR;++ir1) {
	      for(int m1=0; m1<6; ++m1) {
		a1 = TComplex::Conjugate(amp[ir1][i][j][k][m1]);
		if((a1.Rho2())<1e-10) continue;
		for(int ir2=0; ir2<NR;++ir2) {
		  for(int m2=0; m2<6; ++m2) {
		    a2 = amp[ir2][i][j][k][m2];
		    Inte += (a1*a2* AA[i][j][k][ir1][ir2][m1][m2]).Re() ;
		    //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		    
		  }
		}
	      }
	    }
	  }
	}
      }
      //  nres = NZ;  
      
      for(int i=0;i<=1; ++i) {//del
	for(int j=0; j<=1; ++j) { //hel0
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int ir1=0; ir1<NZ;++ir1) {
	      for(int m1=0; m1<12; ++m1) {
		a1 = TComplex::Conjugate(ampZ[ir1][i][j][k][m1]);
		if((a1.Rho2())<1e-10) continue;
		for(int ir2=0; ir2<NZ;++ir2) {
		  for(int m2=0; m2<12; ++m2) {
		    a2 = ampZ[ir2][i][j][k][m2];
		    Inte += (a1*a2* AAZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
		    //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		    
		  }
		}
	      }
	    }
	  }
	}
      }
      
      for(int i=0;i<=1; ++i) {//del
	for(int j=0; j<=1; ++j) { //hel0
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int ir1=0; ir1<NZ;++ir1) {
	      for(int m1=0; m1<12; ++m1) {
		a1 = TComplex::Conjugate(ampZ[ir1][i][j][k][m1]);
		if((a1.Rho2())<1e-10) continue;
		for(int ir2=0; ir2<NR;++ir2) {
		  for(int m2=0; m2<6; ++m2) {
		    a2 = amp[ir2][i][j][k][m2];
		    Inte += 2.*(a1*a2* ABZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
		    //      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		    
		  }
		}
	      }
	    }
	  }
	}
      }
      
      //std::cout <<"sumW " << sumW <<std::endl;
      Inte = Inte/sumW;
    }
  }
  else {Inte = 1.0;  }
  //  std::cout.precision(10);
  //  std::cout << "Integration2, " << Inte << std::endl;  
  
  //update cached resparam
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      ResetDef(ir);
    }
    
    _resParCache[2*ir+0] = m0;
    _resParCache[2*ir+1] = g0;
    
    ir++;
  }
  
  delete coefIter;
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      ResetDef(ir);
    }
    _resParCache[2*ir+0] = m0;
    _resParCache[2*ir+1] = g0;
    
    ir++;
  }
  delete coefIterZ;
  
  return Inte; 
} 

bool RooDalitzAmplitude::checkchange() const
{
  //update cached resparam
  int ir(NR);
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      delete coefIterZ;
      return true;
    }
    ir++;
  }
  delete coefIterZ;
  
  ir = 0; 
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    if((fabs(_resParCache[2*ir+0]-m0)>1e-20)
       || (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      delete coefIter;
      return true;
    }
    
    ir++;
  }
  
  delete coefIter;
  return false;
} 
void RooDalitzAmplitude::ResetDef(int ir) const
{
  if(!_isCach) return;
  int smcnum = PDLZ->size();//smcdata->GetEntries();

  for(int i=0; i<smcnum; i++) {
    //mkp>2GeV
    //if(mkp<2.0) continue;
    Jpsihh_dlz &p = (*PDLZ)[i];
    p.defed[ir] = false;
  }

}


 Int_t RooDalitzAmplitude::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const 
 { 
   // LIST HERE OVER WHICH VARIABLES INTERNAL GENERATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE GENERATOR CONFIGURATION BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES. IF THE FLAG staticInitOK IS TRUE THEN IT IS SAFE TO PRECALCULATE 
   // INTERMEDIATE QUANTITIES IN initGenerator(), IF IT IS NOT SET THEN YOU SHOULD NOT ADVERTISE
   // ANY GENERATOR METHOD THAT RELIES ON PRECALCULATIONS IN initGenerator()

   // if (matchArgs(directVars,generateVars,x)) return 1 ;   
   return 0 ; 
 } 



 void RooDalitzAmplitude::generateEvent(Int_t code) 
 { 
   // GENERATE SET OF OBSERVABLES DEFINED BY RETURN CODE ASSIGNED BY getGenerator()
   // RETURN THE GENERATED VALUES BY ASSIGNING THEM TO THE PROXY DATA MEMBERS THAT
   // REPRESENT THE CHOSEN OBSERVABLES

   // assert(code==1) ; 
   // x = 0 ; 
   return; 
 } 

inline Double_t dfunhalf(Double_t beta, Int_t am, Int_t an) {
  //d1/2_{1/2,1/2}=d1/2_{-1/2,-1/2}=cos(theta/2);
  //d1/2_{1/2,-1/2}=-sin(theta/2)=-d1/2{-1/2,1/2};
  //std::cout << " am an " << am << " " << an << std::endl;
  if((am==1&&an==1) || (am==-1&&an==-1)) return TMath::Cos(0.5*beta);
  if(am==1&&an==-1) return -TMath::Sin(0.5*beta);
  if(am==-1&&an==1) return TMath::Sin(0.5*beta);
  std::cout << "dfunhalf why " << am << " " << an << std::endl;
  return 0.0;
}

inline Double_t dfunone(Double_t beta, Int_t am, Int_t an) {
  if((am==1&&an==1)||(am==-1&&an==-1)) return (TMath::Cos(beta)+1.0)/2.;
  if((am==1&&an==-1)||(am==-1&&an==1)) return (-TMath::Cos(beta)+1.0)/2.;
  if(am==0&&an==1) return TMath::Sin(beta)*7.07106781186547461715e-01;
  if(am==0&&an==-1) return -TMath::Sin(beta)*7.07106781186547461715e-01;
  std::cout << "dfunone why " << am << " " << an << std::endl;
  return 0.0;
}

inline Double_t dfun(Double_t beta, Double_t aj, Double_t am, Double_t an ) {
   //beta in rad;
   // Calculates the beta-term
   //                         d j mn (beta)
   // in the matrix element of the finite rotation operator
   // (Wigner's D-function), according to formula 4.3.1(3) in
   // D.A. Varshalovich, A.N. Moskalev, and V.K. Khersonskii,
   // Quantum Theory of Angular Momentum, World Scientific,
   // Singapore 1988.
   // CERNLIB DDJMNB function translated from Fortran to C++ by Rene Brun

  Double_t pi = 3.141592653589793116;
  Double_t pi2 = 6.283185307179586232;
  //   Double_t beta = beta_rad;
  const Double_t f = 0.5;//8.72664625997164788e-3;   
  const Double_t fcl[51] = { 0 ,0,
			     6.93147180559945309e-1 ,1.79175946922805500e00,
			     3.17805383034794562e00 ,4.78749174278204599e00,
			     6.57925121201010100e00 ,8.52516136106541430e00,
			     1.06046029027452502e01 ,1.28018274800814696e01,
			     1.51044125730755153e01 ,1.75023078458738858e01,
			     1.99872144956618861e01 ,2.25521638531234229e01,
			     2.51912211827386815e01 ,2.78992713838408916e01,
			     3.06718601060806728e01 ,3.35050734501368889e01,
			     3.63954452080330536e01 ,3.93398841871994940e01,
			     4.23356164607534850e01 ,4.53801388984769080e01,
			     4.84711813518352239e01 ,5.16066755677643736e01,
			     5.47847293981123192e01 ,5.80036052229805199e01,
			     6.12617017610020020e01 ,6.45575386270063311e01,
			     6.78897431371815350e01 ,7.12570389671680090e01,
			     7.46582363488301644e01 ,7.80922235533153106e01,
			     8.15579594561150372e01 ,8.50544670175815174e01,
			     8.85808275421976788e01 ,9.21361756036870925e01,
			     9.57196945421432025e01 ,9.93306124547874269e01,
			     1.02968198614513813e02 ,1.06631760260643459e02,
			     1.10320639714757395e02 ,1.14034211781461703e02,
			     1.17771881399745072e02 ,1.21533081515438634e02,
			     1.25317271149356895e02 ,1.29123933639127215e02,
			     1.32952575035616310e02 ,1.36802722637326368e02,
			     1.40673923648234259e02 ,1.44565743946344886e02,
			     1.48477766951773032e02};
  
  Int_t jpm = TMath::Nint(aj+am);
  Int_t jpn = TMath::Nint(aj+an);
  Int_t jmm = TMath::Nint(aj-am);
  
  
  Int_t jmn = TMath::Nint(aj-an);
  Int_t mpn = TMath::Nint(am+an);
  
  Double_t r = 0;
  if (jpm < 0 || jpn < 0 || jmm < 0 || jmn < 0
      
      || aj < 0 || aj > 25 || beta < 0 || beta > pi2) {
    printf("WignerD: Illegal argument(s) aj=%g, am=%g, an=%g, beta=%g\n",aj,am,an,beta);
  } else if (fabs(beta)<1e-10) {
    if (jpm == jpn) r = 1;
  } else if (fabs(beta-pi)<1e-10) {
    if (jpm == jmn) {
      r = 1;
      if (TMath::Abs(jpm)%2 == 1) r = -1;
    }
  } else if (fabs(beta-pi2)<1e-10) {
    if (jpm == jpn) {
      r = 1;
      if (TMath::Abs(mpn)%2 == 1) r = -1;
    }
  } else {
    Double_t b  = f*beta;
    Double_t s  = TMath::Log(TMath::Sin(b));
    Double_t c  = TMath::Log(TMath::Abs(TMath::Cos(b)));
    Double_t rt = 0.5*(fcl[jpm]+fcl[jmm]+fcl[jpn]+fcl[jmn]);
    Int_t k0    = TMath::Max(0,mpn);
    Int_t kq    = k0+jpm;
    if (beta > pi) kq += mpn;
    Double_t q  = 1;
    if (kq%2 == 1) q = -1;
    kq = k0+k0;
    Double_t cx = kq-mpn;
    Double_t sx = jpm+jpn-kq;
    for (Int_t k=k0;k<=TMath::Min(jpm,jpn);k++) {
      r  += q*TMath::Exp(rt-fcl[k]-fcl[jpm-k]-fcl[jpn-k]-fcl[k-mpn]+ cx*c+sx*s);
      cx += 2;
      sx -= 2;
      q   = -q;
    }
    
    
  }
  return r;
}
 
//angluar depdent part for /\*
TComplex RooDalitzAmplitude::MEang(double hel0, double hel3, int delhelmu,
				   double J, double hel1, int hel2, Jpsihh_dlz &dlz) const
{
  double phi1 = dlz.phi1;
  double phi2 = dlz.phi2;
  double phi = 0.0;
  double theta = dlz.theta;
  double theta1 = dlz.theta1;
  double theta2 = dlz.theta2;
  
  double partphi = hel1*phi1+hel2*phi2;//+(hel2-hel1)*phi;
  //  return TComplex(1,partphi,1)*dfun(theta,0.5,hel0,hel1-hel2)
  //*dfun(theta1,J,hel1,hel3)*dfun(theta2,1.,hel2,delhelmu);
  
  return TComplex(1,partphi,1)*dfunhalf(theta,(int)(hel0*2.),(int)((hel1-hel2)*2.))
    *dfun(theta1,J,hel1,hel3)*dfunone(theta2,hel2,delhelmu);
  
//  std::cout << dfun(theta1,J,hel1,hel3)  <<std::endl;
  //return meang;
}

//angluar depdent part for Z
TComplex RooDalitzAmplitude::MEangZ(double helB, double hel3, int delhelmu,
				    double JZ, double helZ, int helpsi, double help, Jpsihh_dlz &dlz) const
{
  if(JZ<fabs((double)helpsi-help)) return 0.0;
  double phiZ = dlz.phiZ;
  double phiMu = dlz.phiMu;
  double phiPsi = dlz.phiPsi;
  double alphaMu = dlz.alphaMu;
  double thetaB = dlz.thetaB;
  double thetaPsi = dlz.thetaPsi;
  double thetaZ = dlz.thetaZ;
  double thetap = dlz.thetap;

  double partphi = helB*phiZ+helpsi*phiMu+helZ*phiPsi+delhelmu*alphaMu;
  return TComplex(1,partphi,1)*dfunone(thetaPsi,helpsi,delhelmu) *
    dfunhalf(thetaB,(int)(helB*2.),(int)(helZ*2.)) *
    dfunhalf(thetap,(int)(help*2.),(int)(hel3*2.)) *//hel3 = hel_p in /\*
    dfun(thetaZ,JZ,helZ,(double)helpsi-help);
  
  // return TComplex(1,partphi,1)*dfunhalf(theta,(int)(hel0*2.),(int)((hel1-hel2)*2.))
  // *dfun(theta1,J,hel1,hel3)*dfunone(theta2,hel2,delhelmu);
  

//  std::cout << dfun(theta1,J,hel1,hel3)  <<std::endl;
  //return meang;
}


void RooDalitzAmplitude::CalCoupling() const
{
  std::cout << "update coupling " << std::endl;
  TComplex ampCoff;  
  double hel0, hel3;
  int delhelmu;
  double S, hel1, hel2;
  int S2,LR;
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    int iressize = ires.getSize();
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = (int)(S-0.5);
    //(-1)*(-1)^LR = P_Ln
    if((pow(-1,LR+1)*parity)<0) LR += 1;

    double paritypart;
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  paritypart = 1.; // parity conservation of /\n decay 
	  if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	  // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	  for(int m=0; m<6; ++m) {
	    //	    amp[ir][i][j][k][m] = 0.0;
	    if(fabs(S-0.5)<1e-10&&m>=4) {
	      continue;
	    }
	    hel1 = (double)Hel1Two[m]/2.;
	    hel2 = Hel2[m];
	    //	      std::cout << "defined .. " << std::endl;
#ifdef PAW 
	    ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
#else
	    ampCoff = HelicityCoff(ires,m)*paritypart;
#endif
	    amp[ir][i][j][k][m] = ampCoff;
	  }
	}
      }
    }
    ir++;
  }
  delete coefIter;
  
  int irZ(0);
  double help, helZ;
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = TMath::Max((int)(S-1.5),0);
    //(-1)*(-1)^LR = P_Lz
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    //Rj BW here
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  
	  //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	  int m(0);
	  for(int helpsi = -1; helpsi <=1; ++helpsi) {
	    for(int ihz = 0; ihz<=1; ++ihz) {
	      helZ = (ihz==0) ? -0.5: 0.5;
	      for(int ihp = 0; ihp<=1; ++ihp) {
		help = (ihp==0) ? -0.5: 0.5;
		if(fabs((double)helpsi-help)>S) continue;
		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));	
//		std::cout << "amp Z " << ampCoff << std::endl;
//		std::cout << "m " << m<<std::endl;
		ampZ[irZ][i][j][k][m] = ampCoff;
		m++;
	      }
	    }
	  }
	}
      }
    }
    irZ++;
  }
  delete coefIterZ;
}

Double_t RooDalitzAmplitude::GetAmp2s(Jpsihh_dlz &dlz, int isintcal) const
{
  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
  for(int i=0;i<=1; ++i) {
    for(int j=0; j<=1; ++j) {
      for(int k=0; k<=1; ++k) {
	H[i][j][k] = TComplex(0,0);
      }
    }
  }
  
  double re_i, im_i;
  double hel0, hel3;
  int delhelmu;
  double S, hel1, hel2;
  double mkp(dlz.mkp);
  int S2,LR;
  
  TComplex ampCoff, AIndep;
  double Bterm;
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    int iressize = ires.getSize();
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = (int)(S-0.5);
    //(-1)*(-1)^LR = P_Ln
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    double paritypart;
    bool notdefined = !(dlz.defed[ir]);
    //    notdefined = 1;
    if( notdefined
	//check if need to update cached amplitude if mass or widht changes
	|| (fabs(_resParCache[2*ir+0]-m0)>1e-20)
	|| (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      
      BW_AMP(m0,g0,mkp,LR,re_i, im_i);
      Bterm = BTerm(S, mkp, m0);
      
      for(int i=0;i<=1; ++i) {//del
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    paritypart = 1.; // parity conservation of /\n decay 
	    if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int m=0; m<6; ++m) {
	      dlz.ARe[ir][i][j][k][m] = 0.0;
	      dlz.AIm[ir][i][j][k][m] = 0.0;
	      //amp[ir][i][j][k][m] = 0.0;
	      if(fabs(S-0.5)<1e-10&&m>=4) {
		//	dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		continue;
	      }
	      hel1 = (double)Hel1Two[m]/2.;
	      hel2 = Hel2[m];
	      /*
		#ifdef PAW 
		ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
		#else
		ampCoff = HelicityCoff(ires,m)*paritypart;
		#endif
	      */
	      ampCoff = amp[ir][i][j][k][m];
	      if((ampCoff.Rho2())<1e-10 && isintcal==0) continue;	      
	      
	      AIndep = TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	      dlz.ARe[ir][i][j][k][m] = AIndep.Re();
	      dlz.AIm[ir][i][j][k][m] = AIndep.Im();
	      H[i][j][k] += ampCoff * AIndep;
	      if(m==0) dlz.defed[ir] = true;
	    }
	  }
	}
      }
    } else{
      
      for(int i=0;i<=1; ++i) {//delmu
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    paritypart = 1.; // parity conservation of /\n decay 
	    if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int m=0; m<6; ++m) {
	      //amp[ir][i][j][k][m] = 0.0;
	      if(fabs(S-0.5)<1e-10&&m>=4) {
		continue;
	      }
	      hel1 = (double)Hel1Two[m]/2.;
	      hel2 = Hel2[m];
//	    	      std::cout << "defined .. " << std::endl;
	      /*#ifdef PAW 
		ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
		#else
		ampCoff = HelicityCoff(ires,m)*paritypart;
		#endif
	      */
	      ampCoff = amp[ir][i][j][k][m];
	      
	      if((ampCoff.Rho2())<1e-10) continue;
	      //	      AIndep = 
	      H[i][j][k] += ampCoff * TComplex(dlz.ARe[ir][i][j][k][m], dlz.AIm[ir][i][j][k][m]);//TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);;
	      //H[i][j][k] += ampCoff*BTerm(S,mkp,m0,hel3, parity)*TComplex(re_i, im_i)*MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	    }
	  }
	}  
      }
      
    }
    ir++;
  }
  
  //Z part
  int irZ(0);
  double help, helZ;
  double mjpsip(dlz.mjpsip);
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = TMath::Max((int)(S-1.5),0);
    //(-1)*(-1)^LR = P_Lz
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    bool notdefined = !(dlz.defed[ir]);
    if( notdefined
	//check if need to update cached amplitude if mass or widht changes
	|| (fabs(_resParCache[2*ir+0]-m0)>1e-20)
	|| (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
      
      BW_AMPZ(m0,g0,mjpsip,LR,re_i, im_i);
      Bterm = BTermZ(S, mjpsip, m0);
      
      //Rj BW here
      for(int i=0;i<=1; ++i) {//delmu
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	    int m(0);
	    for(m=0; m<12; ++m) {
	      dlz.AZRe[irZ][i][j][k][m] = 0.0;
	      dlz.AZIm[irZ][i][j][k][m] = 0.0;
	    }
	    m=0;
	    for(int helpsi = -1; helpsi <=1; ++helpsi) {
	      for(int ihz = 0; ihz<=1; ++ihz) {
		helZ = (ihz==0) ? -0.5: 0.5;
		for(int ihp = 0; ihp<=1; ++ihp) {
		  help = (ihp==0) ? -0.5: 0.5;
		  if(fabs((double)helpsi-help)>S) continue;
		  ampCoff = ampZ[irZ][i][j][k][m];
		  //ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));	
		  //		std::cout << "helpsi helZ help co " << helpsi << " " << helZ << " " << help << " " << ampCoff << std::endl;	
		  if((ampCoff.Rho2())<1e-10 && isintcal==0) { m++; continue;	}      		
		  AIndep = TComplex(re_i, im_i) * Bterm * MEangZ(hel0, hel3, delhelmu, S, helZ, helpsi, help, dlz);
		  dlz.AZRe[irZ][i][j][k][m] = AIndep.Re();
		  dlz.AZIm[irZ][i][j][k][m] = AIndep.Im();
		  
		  //		std::cout << "helZ helpsi help amp " << helZ << " " << helpsi << " " << help << " " << ampCoff << std::endl;
		  //	TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
		  H[i][j][k] += ampCoff * AIndep;
		  if(m==0) dlz.defed[ir] = true;		
		  m++;
		}
	      }
	    }
	  }
	}
      }
    } else {
      //Rj BW here
      for(int i=0;i<=1; ++i) {//delmu
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    
	    //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	    int m(0);
	    for(int helpsi = -1; helpsi <=1; ++helpsi) {
	      for(int ihz = 0; ihz<=1; ++ihz) {
		helZ = (ihz==0) ? -0.5: 0.5;
		for(int ihp = 0; ihp<=1; ++ihp) {
		  help = (ihp==0) ? -0.5: 0.5;
		  if(fabs((double)helpsi-help)>S) continue;
		  ampCoff = ampZ[irZ][i][j][k][m];
		  
		  //		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));		
		  if((ampCoff.Rho2())<1e-10) { m++; continue;	}      		
		  //		AIndep = TComplex(re_i, im_i) * Bterm * MEangZ(hel0, hel3, delhelmu, S, helZ, helpsi, help, dlz);
		  //dlz.AZRe[irZ][i][j][k][m] = AIndep.Re();
		  //		dlz.AZIm[irZ][i][j][k][m] = AIndep.Im();
		  
		  //		std::cout << "helZ helpsi help amp " << helZ << " " << helpsi << " " << help << " " << ampCoff << std::endl;
		  //	TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
		  H[i][j][k] += ampCoff * TComplex(dlz.AZRe[irZ][i][j][k][m],dlz.AZIm[irZ][i][j][k][m]);//AIndep;
		  m++;
		}
	      }
	    }
	  }
	}
      }
    }
    ir++;
    irZ++;
  }
  double totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2()
    + H[0][1][0].Rho2() + H[0][1][1].Rho2()
    + H[1][0][0].Rho2() + H[1][0][1].Rho2()
    + H[1][1][0].Rho2() + H[1][1][1].Rho2();
  
  delete coefIter;  
  delete coefIterZ;    
  return totalA;  
}

//group = 0 for each component, = 1 Lambda = 2 Z
Double_t RooDalitzAmplitude::GetAmp2sForInt(Jpsihh_dlz &dlz, int index, int group) const
{
  int isintcal(1);
  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
  for(int i=0;i<=1; ++i) {
    for(int j=0; j<=1; ++j) {
      for(int k=0; k<=1; ++k) {
	H[i][j][k] = TComplex(0,0);
      }
    }
  }
  
  double re_i, im_i;
  double hel0, hel3;
  int delhelmu;
  double S, hel1, hel2;
  double mkp(dlz.mkp);
  int S2,LR;
  
  TComplex ampCoff, AIndep;
  double Bterm;
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    if((group!=1)&&!(group==0&&ir==index)) {ir++; continue;}
    int iressize = ires.getSize();
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = (int)(S-0.5);
    //(-1)*(-1)^LR = P_Ln
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    double paritypart;
    //bool notdefined = !(dlz.defed[ir]);
    //    notdefined = 1;
    
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  paritypart = 1.; // parity conservation of /\n decay 
	  if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	  // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	  for(int m=0; m<6; ++m) {
	    //amp[ir][i][j][k][m] = 0.0;
	    if(fabs(S-0.5)<1e-10&&m>=4) {
	      continue;
	    }
	    hel1 = (double)Hel1Two[m]/2.;
	    hel2 = Hel2[m];
	    //	      std::cout << "defined .. " << std::endl;
	    /*#ifdef PAW 
	      ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
	      #else
	      ampCoff = HelicityCoff(ires,m)*paritypart;
	      #endif
	    */
	    ampCoff = amp[ir][i][j][k][m];
	    
	    if((ampCoff.Rho2())<1e-10) continue;
	    //	      AIndep = 
	    H[i][j][k] += ampCoff * TComplex(dlz.ARe[ir][i][j][k][m], dlz.AIm[ir][i][j][k][m]);//TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);;
	    //H[i][j][k] += ampCoff*BTerm(S,mkp,m0,hel3, parity)*TComplex(re_i, im_i)*MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	  }
	}
      }  
    }
    
    ir++;
  }
  
  //Z part
  int irZ(0);
  double help, helZ;
  double mjpsip(dlz.mjpsip);
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    if((group!=2)&&!(group==0&&ir==index)) {ir++; irZ++; continue;}    
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = TMath::Max((int)(S-1.5),0);
    //(-1)*(-1)^LR = P_Lz
    if((pow(-1,LR+1)*parity)<0) LR += 1;    
    
    //Rj BW here
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  
	  //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	  int m(0);
	  for(int helpsi = -1; helpsi <=1; ++helpsi) {
	    for(int ihz = 0; ihz<=1; ++ihz) {
	      helZ = (ihz==0) ? -0.5: 0.5;
	      for(int ihp = 0; ihp<=1; ++ihp) {
		help = (ihp==0) ? -0.5: 0.5;
		if(fabs((double)helpsi-help)>S) continue;
                ampCoff = ampZ[irZ][i][j][k][m];
		
		//		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));		
		if((ampCoff.Rho2())<1e-10) { m++; continue;	}      		
		//	
		H[i][j][k] += ampCoff * TComplex(dlz.AZRe[irZ][i][j][k][m],dlz.AZIm[irZ][i][j][k][m]);//AIndep;
		m++;
	      }
	    }
	  }
	}
      }
      
    }
    ir++;
    irZ++;
  }

  
  
  double totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2()
                + H[0][1][0].Rho2() + H[0][1][1].Rho2()
                + H[1][0][0].Rho2() + H[1][0][1].Rho2()
                + H[1][1][0].Rho2() + H[1][1][1].Rho2();

  delete coefIter;  
  delete coefIterZ;  

  return totalA;  
}

/*
Double_t RooDalitzAmplitude::GetAmp2sForInt(Jpsihh_dlz &dlz, int index) const
{
  int isintcal(1);
  TComplex H[2][2][2];//delhelmu=+/-1,hel0=+/-1/2,hel3=+/-1/2
  for(int i=0;i<=1; ++i) {
    for(int j=0; j<=1; ++j) {
      for(int k=0; k<=1; ++k) {
	H[i][j][k] = TComplex(0,0);
      }
    }
  }
  
  double re_i, im_i;
  double hel0, hel3;
  int delhelmu;
  double S, hel1, hel2;
  double mkp(dlz.mkp);
  int S2,LR;
  
  TComplex ampCoff, AIndep;
  double Bterm;
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    if(ir!=index) {ir++; continue;}
    int iressize = ires.getSize();
    
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = (int)(S-0.5);
    //(-1)*(-1)^LR = P_Ln
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    double paritypart;
    //    bool notdefined = !(dlz.defed[ir]);
    //    notdefined = 1;
//    if( notdefined
	//check if need to update cached amplitude if mass or widht changes
//	|| (fabs(_resParCache[2*ir+0]-m0)>1e-20)
//	|| (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
    if(0) {  
      BW_AMP(m0,g0,mkp,LR,re_i, im_i);
      Bterm = BTerm(S, mkp, m0);

      for(int i=0;i<=1; ++i) {//del
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    paritypart = 1.; // parity conservation of /\n decay 
	    if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int m=0; m<6; ++m) {
	      dlz.ARe[ir][i][j][k][m] = 0.0;
	      dlz.AIm[ir][i][j][k][m] = 0.0;
	      if(fabs(S-0.5)<1e-10&&m>=4) {
		//	dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		continue;
	      }
	      hel1 = (double)Hel1Two[m]/2.;
	      hel2 = Hel2[m];

#ifdef PAW 
	      ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
#else
	      ampCoff = HelicityCoff(ires,m)*paritypart;
#endif
	       if((ampCoff.Rho2())<1e-10 && isintcal==0) continue;	      
	      
	      AIndep = TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	      dlz.ARe[ir][i][j][k][m] = AIndep.Re();
	      dlz.AIm[ir][i][j][k][m] = AIndep.Im();
	      H[i][j][k] += ampCoff * AIndep;
	      if(m==0) dlz.defed[ir] = true;
	    }
	  }
	}
      }
    } else{
      
      for(int i=0;i<=1; ++i) {//delmu
	delhelmu = (i==0) ? -1: 1;
	for(int j=0; j<=1; ++j) { //hel0
	  hel0 = (j==0) ? -0.5: 0.5;
	  for(int k=0; k<=1; ++k) { //hel3 proton
	    hel3 = (k==0) ? -0.5: 0.5;
	    paritypart = 1.; // parity conservation of /\n decay 
	    if(hel3<0)   paritypart = pow(-1.,(int)(S-1.5))*parity;
	    // [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	    for(int m=0; m<6; ++m) {
	      if(fabs(S-0.5)<1e-10&&m>=4) {
		continue;
	      }
	      hel1 = (double)Hel1Two[m]/2.;
	      hel2 = Hel2[m];
	      //	      std::cout << "defined .. " << std::endl;
#ifdef PAW 
	      ampCoff = PartWaveCoff(ires, S2, Hel1Two[m], hel2*2)*paritypart;
#else
	      ampCoff = HelicityCoff(ires,m)*paritypart;
#endif
	      if((ampCoff.Rho2())<1e-10) continue;
	      //	      AIndep = 
	      H[i][j][k] += ampCoff * TComplex(dlz.ARe[ir][i][j][k][m], dlz.AIm[ir][i][j][k][m]);//TComplex(re_i, im_i) * Bterm *MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);;
	      //H[i][j][k] += ampCoff*BTerm(S,mkp,m0,hel3, parity)*TComplex(re_i, im_i)*MEang(hel0,hel3,delhelmu,S,hel1,hel2,dlz);
	    }
	  }
	}  
      }
      
    }
    ir++;
  }

  //Z part
  int irZ(0);
  double help, helZ;
  double mjpsip(dlz.mjpsip);
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    //    int type = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    if(ir!=index) {ir++; irZ++; continue;}    
    //if (type!=1&&type!=2&&type!=3&&type!=4) continue;
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    //spin; inputs is 2xspin
    int parity = (int)((RooAbsReal&)ires[iressize-1]).getVal();
    S2 = (int) ((RooAbsReal&)ires[iressize-2]).getVal();
    S = (double)S2/2.;
    LR = TMath::Max((int)(S-1.5),0);
    //(-1)*(-1)^LR = P_Lz
    if((pow(-1,LR+1)*parity)<0) LR += 1;
    
    // bool notdefined = !(dlz.defed[ir]);
//    if( notdefined
	//check if need to update cached amplitude if mass or widht changes
//	|| (fabs(_resParCache[2*ir+0]-m0)>1e-20)
	//|| (fabs(_resParCache[2*ir+1]-g0)>1e-20) ) {
    if(0) {  
    BW_AMPZ(m0,g0,mjpsip,LR,re_i, im_i);
    Bterm = BTermZ(S, mjpsip, m0);

    //Rj BW here
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  
	  //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	  int m(0);
	  for(int helpsi = -1; helpsi <=1; ++helpsi) {
	    for(int ihz = 0; ihz<=1; ++ihz) {
	      helZ = (ihz==0) ? -0.5: 0.5;
	      for(int ihp = 0; ihp<=1; ++ihp) {
		help = (ihp==0) ? -0.5: 0.5;
		if(fabs((double)helpsi-help)>S) continue;
		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));		
	       if((ampCoff.Rho2())<1e-10 && isintcal==0) { m++; continue;	}      		
		AIndep = TComplex(re_i, im_i) * Bterm * MEangZ(hel0, hel3, delhelmu, S, helZ, helpsi, help, dlz);
		dlz.AZRe[irZ][i][j][k][m] = AIndep.Re();
		dlz.AZIm[irZ][i][j][k][m] = AIndep.Im();

		//		std::cout << "helZ helpsi help amp " << helZ << " " << helpsi << " " << help << " " << ampCoff << std::endl;
		//	TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
		H[i][j][k] += ampCoff * AIndep;
      	      if(m==0) dlz.defed[ir] = true;		
		m++;
	      }
	    }
	  }
	}
      }
    }
  } else {
      //Rj BW here
    for(int i=0;i<=1; ++i) {//delmu
      delhelmu = (i==0) ? -1: 1;
      for(int j=0; j<=1; ++j) { //hel0
	hel0 = (j==0) ? -0.5: 0.5;
	for(int k=0; k<=1; ++k) { //hel3 proton
	  hel3 = (k==0) ? -0.5: 0.5;
	  
	  //there are 12 amplitudes to be added coherently //helpsi,0,+/-1, helZ,+/-1/2, help=+/-1/2
	  int m(0);
	  for(int helpsi = -1; helpsi <=1; ++helpsi) {
	    for(int ihz = 0; ihz<=1; ++ihz) {
	      helZ = (ihz==0) ? -0.5: 0.5;
	      for(int ihp = 0; ihp<=1; ++ihp) {
		help = (ihp==0) ? -0.5: 0.5;
		if(fabs((double)helpsi-help)>S) continue;
		ampCoff = PartWaveCoffZ(ires, S2, (int)(helZ*2.), (int)(helpsi*2.), (int)(help*2.));		
	       if((ampCoff.Rho2())<1e-10) { m++; continue;	}      		
//		AIndep = TComplex(re_i, im_i) * Bterm * MEangZ(hel0, hel3, delhelmu, S, helZ, helpsi, help, dlz);
		//dlz.AZRe[irZ][i][j][k][m] = AIndep.Re();
//		dlz.AZIm[irZ][i][j][k][m] = AIndep.Im();

		//		std::cout << "helZ helpsi help amp " << helZ << " " << helpsi << " " << help << " " << ampCoff << std::endl;
		//	TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
		H[i][j][k] += ampCoff * TComplex(dlz.AZRe[irZ][i][j][k][m],dlz.AZIm[irZ][i][j][k][m]);//AIndep;
		m++;
	      }
	    }
	  }
	}
      }
    }
  }
  ir++;
  irZ++;
  }
  double totalA = H[0][0][0].Rho2() + H[0][0][1].Rho2()
                + H[0][1][0].Rho2() + H[0][1][1].Rho2()
                + H[1][0][0].Rho2() + H[1][0][1].Rho2()
                + H[1][1][0].Rho2() + H[1][1][1].Rho2();

  delete coefIter;  
  delete coefIterZ;  

  return totalA;  
}
*/

void RooDalitzAmplitude::getIFandFF() const
{

  CalCoupling();
//  analyticalIntegral(7);
  IntegralMethod1();
  Double_t Inte(0);
  Double_t FFL(0), FFZ(0);
  Double_t InteL[NR][NR], InteZ[NZ][NZ], InteLZ[NZ][NR];
//  Double_t IFFF[NR+NZ][NR+NZ];
  TMatrixD IFFF(NR+NZ,NR+NZ);

  for(int ir1=0;ir1<NR; ++ir1) {
    for(int ir2=0; ir2<NR; ++ir2) {
      InteL[ir1][ir2] = 0.0;
    }
  }
  for(int ir1=0;ir1<NZ; ++ir1) {
    for(int ir2=0; ir2<NR; ++ir2) {
      InteLZ[ir1][ir2] = 0.0;
    }
  }
  for(int ir1=0;ir1<NZ; ++ir1) {
    for(int ir2=0; ir2<NZ; ++ir2) {
      InteZ[ir1][ir2] = 0.0;
    }
  }

  TComplex a1,a2;
  for(int i=0;i<=1; ++i) {//del
    for(int j=0; j<=1; ++j) { //hel0
      for(int k=0; k<=1; ++k) { //hel3 proton
	// [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	for(int ir1=0; ir1<NR;++ir1) {
	  for(int m1=0; m1<6; ++m1) {
	    a1 = TComplex::Conjugate(amp[ir1][i][j][k][m1]);
	    if((a1.Rho2())<1e-10) continue;
	    for(int ir2=0; ir2<NR;++ir2) {
	      for(int m2=0; m2<6; ++m2) {
		a2 = amp[ir2][i][j][k][m2];
		double tmp = (a1*a2* AA[i][j][k][ir1][ir2][m1][m2]).Re() ;
		InteL[ir1][ir2] += tmp;
		Inte += tmp;
		FFL += tmp;
		//      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		
	      }
	    }
	  }
	}
      }
    }
  }
  //  nres = NZ;  
  
  for(int i=0;i<=1; ++i) {//del
    for(int j=0; j<=1; ++j) { //hel0
      for(int k=0; k<=1; ++k) { //hel3 proton
	// [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	for(int ir1=0; ir1<NZ;++ir1) {
	  for(int m1=0; m1<12; ++m1) {
	    a1 = TComplex::Conjugate(ampZ[ir1][i][j][k][m1]);
	    if((a1.Rho2())<1e-10) continue;
	    for(int ir2=0; ir2<NZ;++ir2) {
	      for(int m2=0; m2<12; ++m2) {
		a2 = ampZ[ir2][i][j][k][m2];
		double tmp = (a1*a2* AAZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
		InteZ[ir1][ir2] += tmp;
		//      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		Inte += tmp;
		FFZ += tmp;
	      }
	    }
	  }
	}
      }
    }
  }
  
  for(int i=0;i<=1; ++i) {//del
    for(int j=0; j<=1; ++j) { //hel0
      for(int k=0; k<=1; ++k) { //hel3 proton
	// [1/2,1] [1/2,0] [-1/2, 0] [-1/2, -1] [3/2,1] [-3/2, -1]
	for(int ir1=0; ir1<NZ;++ir1) {
	  for(int m1=0; m1<12; ++m1) {
	    a1 = TComplex::Conjugate(ampZ[ir1][i][j][k][m1]);
	    if((a1.Rho2())<1e-10) continue;
	    for(int ir2=0; ir2<NR;++ir2) {
	      for(int m2=0; m2<6; ++m2) {
		a2 = amp[ir2][i][j][k][m2];
		double tmp = 2.*(a1*a2* ABZ[i][j][k][ir1][ir2][m1][m2]).Re() ;
		InteLZ[ir1][ir2] += tmp;
		//      dlz.A[ir][m][i][j][k] = TComplex(0.,0.);
		Inte += tmp;
	      }
	    }
	  }
	}
      }
    }
  }

  for(int ir1=0;ir1<NR; ++ir1) {
    for(int ir2=0; ir2<NR; ++ir2) {
      IFFF(ir1,ir2) = 100.*InteL[ir1][ir2]/Inte;
    }
  }
  for(int ir1=0;ir1<NZ; ++ir1) {
    for(int ir2=0; ir2<NZ; ++ir2) {
      IFFF(ir1+NR,ir2+NR) = 100.*InteZ[ir1][ir2]/Inte;
    }
  }
  for(int ir1=0;ir1<NZ; ++ir1) {
    for(int ir2=0; ir2<NR; ++ir2) {
      IFFF(ir1+NR,ir2) = 100.*InteLZ[ir1][ir2]/2./Inte;
      IFFF(ir2,ir1+NR) = 100.*InteLZ[ir1][ir2]/2./Inte;      
    }
  }    
  IFFF.Print("f= %15.8g");
  std::cout <<"FF L and Z " << FFL/Inte << " " << FFZ/Inte << std::endl;
  //std::cout <<"sumW " << sumW <<std::endl;   
}

void RooDalitzAmplitude::getInt(double *vint, double ylo, double yhi) const
{
  CalCoupling();
  
  int nres = NR+NZ;
  double a0[20];
  for(Int_t i=0; i<20; ++i) {
    a0[i] = 0;
  }
  int smcnum = pdlz->size();//smcdata->GetEntries();
  
  double val, sweight;
  double sumw(0);
  for(int i=0; i<smcnum; i++) {
    
    //mkp>2GeV
    //if(mkp<2.0) continue;
    Jpsihh_dlz &p = (*pdlz)[i];
    if(p.mkp<ylo||p.mkp>yhi) continue;
    //    filldlz(p, mkp, costheta, costheta1, costheta2, phi1, phi2, phi);
    val =  GetAmp2s(p,1);    
    sweight = p.w;
    sumw += sweight;
    a0[0] += val*sweight;
    for(int k = 1; k<=nres; ++k) {
      val = GetAmp2sForInt(p,k-1);
      a0[k] += val*sweight;
    }
  }
  
  std::cout << "Flat MC norm " << a0[0]/sumw << std::endl;
  for(int k=1; k<=nres;++k) vint[k-1] = a0[k]/a0[0];

  //  std::cout << "Integration " << inte << std::endl;
  
  
  //update cached resparam
  int ir(0);
  TIterator* coefIter=_resList->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIter->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    _resParCache[2*ir+0] = m0;
    _resParCache[2*ir+1] = g0;
    
    ir++;
  }
  delete coefIter;
  TIterator* coefIterZ=_resListZ->MakeIterator();
  while(RooArgList* Ires = (RooArgList*)coefIterZ->Next()) {
    RooArgList ires = (*Ires);
    int iressize = ires.getSize();
    double m0 = 0;
    double g0 = 0;
    m0 = ((RooAbsReal&)ires[iressize-4]).getVal();
    g0 = ((RooAbsReal&)ires[iressize-3]).getVal();
    
    _resParCache[2*ir+0] = m0;
    _resParCache[2*ir+1] = g0;
    
    ir++;
  }
  delete coefIterZ;
  

} 

  


//fit will use Re, Im as inputs
TComplex RooDalitzAmplitude::HelicityCoff(RooArgList ires, Int_t ihel) const
{
   
  return TComplex(((RooAbsReal&)ires[ihel*2]).getVal(),((RooAbsReal&)ires[ihel*2+1]).getVal());
  
}

//here all quantum numbers are 2 x
/* 
TComplex RooDalitzAmplitude::PartWaveCoff(RooArgList ires, int J, int lambda2, int lambda3) const
{
  //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
  //2L = 2*S-1, 2*S + 1;
  //s2 and s3 are two times of hel2, hel3
  //  int J = 2*spin;
  int ib(0);
  TComplex c(0);
  int s2(J), s3(2);//2xspin of L; jpsi
  int JB(1);
  int m1 = lambda2-lambda3;
  EvtCGCoefSingle c1(s2,s3);
  for(int S = abs(J-2); S<=J+2; S+=2) {
    for(int L = S - 1; L<= S + 1; L+=2) {
      TComplex M(((RooAbsReal&)ires[ib*2]).getVal(),((RooAbsReal&)ires[ib*2+1]).getVal());
      if(fabs(M.Rho2()<1e-10)) { ib++; continue;}
      double fkwTmp = (L+1.0)/(S+1.0);
      EvtCGCoefSingle c2(L,S);
      TComplex tmp=sqrt(fkwTmp)
	*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
	*c2.coef(JB,m1,L,S,0,m1)*M;
      //std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " " << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
      c += tmp;
      ib++;
    }
  }
  return c;
}
*/

//here all quantum numbers are 2 x
TComplex RooDalitzAmplitude::PartWaveCoff(RooArgList ires, int J, int lambda2, int lambda3) const
{
  //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
  //2L = 2*S-1, 2*S + 1;
  //s2 and s3 are two times of hel2, hel3
  //  int J = 2*spin;
  int ib(0);
  TComplex c(0);
  int s2(J), s3(2);//2xspin of L; jpsi
  int JB(1);
  int m1 = lambda2-lambda3;
//  EvtCGCoefSingle c1(s2,s3);
  for(int S = abs(J-2); S<=J+2; S+=2) {
    for(int L = S - 1; L<= S + 1; L+=2) {
      TComplex M(((RooAbsReal&)ires[ib*2]).getVal(),((RooAbsReal&)ires[ib*2+1]).getVal());
      if((M.Rho2()<1e-10)) { ib++; continue;}
      double fkwTmp = (L+1.0)/(JB+1.0);
//      EvtCGCoefSingle c2(L,S);
    //  EvtCGCoefSingle c1(s2,s3);
  //   std::cout << "begin " << S << " " << L << std::endl;
     double ccg(1.);
     switch(s2) {
      case 1: {
         ccg = CG1.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      case 3: {
         ccg = CG3.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      case 5: {
         ccg = CG5.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      case 7: {
         ccg = CG7.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      case 9: {
         ccg = CG9.coef(S,m1,s2,s3,lambda2,-lambda3);
         break;
      }
      default: std::cout << "CG wrong" << std::endl;
     }
      TComplex tmp=sqrt(fkwTmp)
        *ccg
	//*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
//	*c2.coef(JB,m1,L,S,0,m1)*M;
        *C2[(S-1)/2][(L-S+1)/2]*M;
//        std::cout << "end" << std::endl;
      if(m1<0&&L>S) tmp   = -tmp;
      //std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " " << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
      c += tmp;
      ib++;
    }
  }
  return c;
}


//here all quantum numbers are 2 x
TComplex RooDalitzAmplitude::PartWaveCoffZ(RooArgList ires, int J, int lambdaZ, int lambdaPsi, int lambdap) const
{
  TComplex HB(0,0);
  int SB = J;//2xZ spin
  for(int LB = SB - 1; LB<= SB + 1; LB+=2) {
    TComplex tmp = TComplex(1.0,0)*C2[(SB-1)/2][(LB-SB+1)/2]*sqrt((LB+1.0)/2.0);
    if(LB>SB) {
      TComplex M(((RooAbsReal&)ires[0]).getVal(),((RooAbsReal&)ires[1]).getVal());
      if((M.Rho2()<1e-10)) {tmp = 0.0; continue;  }
      tmp = tmp * M;
      if(lambdaZ<0) tmp  = -tmp;
    }
    HB += tmp;
  }

  
  //|2*J_L - 2|<=2S<= 2*J_L+2 === odd 1,3,5,7...;
  //2L = 2*S-1, 2*S + 1;
  //s2 and s3 are two times of hel2, hel3
  //  int J = 2*spin;

  int parity = (int)((RooAbsReal&)ires[ires.getSize()-1]).getVal();
   
  int ib(1);
  TComplex c(0);
  int m1 = lambdaPsi-lambdap;
  
  double ccg1(1.0);
  for(int S = 1; S <=3 ; S+=2) {
    for(int L = abs(J -S); L<= J + S; L+=2) {
      //(-1)*(-1)^LR = P_Lz
      if((pow(-1,(int)(L/2)+1)*parity)<0) continue;
      // std::cout << "S L " << S << " " << L << std::endl;
      if(S<abs(m1)) {ib++; continue; } 
      ccg1 = CG21.coef(S,m1,2,1,lambdaPsi,-lambdap);
      //  EvtCGCoefSingle c1(s2,s3);
      //std::cout << "ib " << ib << std::endl;
      if(ib>=4) std::cout << "why Z parity" << std::endl;
      TComplex M(((RooAbsReal&)ires[ib*2]).getVal(),((RooAbsReal&)ires[ib*2+1]).getVal());
      //std::cout << "M " << M << std::endl;
      if((M.Rho2()<1e-10)) { ib++; continue;}
      double fkwTmp = (L+1.0)/(J+1.0); //S should be JB;
    
      //      EvtCGCoefSingle c2(L,S);
      //  EvtCGCoefSingle c1(s2,s3);
      //   std::cout << "begin " << S << " " << L << std::endl;
      double ccg(1.);
      if(J==1) {
        ccg = C2[(S-1)/2][(L-S+1)/2];
        if(m1<0&&L>S) ccg   = -ccg;
      } else if(J==3) {
        if(S==1) {
          if(L==2) {
	    ccg = CG21.coef(J,m1,L,S,0,m1);
          }else if(L==4) {
	    ccg = CG41.coef(J,m1,L,S,0,m1);
          } else { 
	    std::cout << "why CG J==3 S==1 L" << std::endl; 
	    ccg = 0.0;
          } 
	}else if(S==3) {
	  switch(L) {
	  case 0: {
	    ccg = CG03.coef(J,m1,L,S,0,m1);
	    break;
	  }
	  case 2: {
	    ccg = CG23.coef(J,m1,L,S,0,m1);
	    break;
	  }
	  case 4: {
	    ccg = CG43.coef(J,m1,L,S,0,m1);
	    break;
	  }
	  case 6: {
	    ccg = CG63.coef(J,m1,L,S,0,m1);
	    break;
	  }
	    
	  default: std::cout << "CG wrong" << std::endl;
	  }          
	} else {
	  std::cout << " why CG J==3 S?" << std::endl;
	  ccg = 0.0;
	}   
      } else {
	EvtCGCoefSingle c2(L,S);
	ccg = c2.coef(J,m1,L,S,0,m1);
      }
      
      TComplex tmp=sqrt(fkwTmp)*
        ccg
	//*c1.coef(S,m1,s2,s3,lambda2,-lambda3)
	//	*c2.coef(JB,m1,L,S,0,m1)*M;
        *ccg1*M;
      //        std::cout << "end" << std::endl;
      //      if(m1<0&&L>S) tmp   = -tmp;
      //std::cout << "Test CG spin L S m1 " << J << " " << L << " " << S << " " << m1<< " " << c1.coef(S,m1,s2,s3,lambda2,-lambda3)*c2.coef(JB,m1,L,S,0,m1) << std::endl;
      c += tmp;
      ib++;
    }
  }
  return c*HB;
}

Double_t RooDalitzAmplitude::BTerm(Double_t Spin, Double_t mpp, Double_t mr) const
{
  Double_t c(0);
  
  //  double pi=TMath::Pi();
  // double deg2rad = pi/180.;
  
  Double_t J = Spin;
  int LB = (int)(J-1.5);
  if(LB<0) LB = 0;

  double pB = getp(m_lb, m_jpsi, mpp);
  //for NR
  if(mr<-500.) return pow(pB/m_lb, LB); 
  double pB0 = pB;
  if(mr>1e-10&&mr+m_jpsi<m_lb) pB0 = getp(m_lb, m_jpsi, mr);
  if(mr+m_jpsi>m_lb) {
    double mmin = m_k+m_p;
    double mmax = m_lb-m_jpsi;
    double mreff = mmin+0.5*(mmax-mmin)*(1.0+tanh((mr-(mmin+mmax)/2.)/(mmax-mmin)));
    pB0 = getp(m_lb, m_jpsi, mreff);
  }    
  //  double phi00 = ((RooAbsReal&)ires[ihel*2+1]).getVal()*deg2rad;
  c = F_BW(_FFB,LB,pB,pB0) * pow(pB/m_lb, LB);
  // if(h3<0) //lamda_3 <0 /\->pK strong decay???
  //
  
  return c;
  
}

Double_t RooDalitzAmplitude::BTermZ(Double_t Spin, Double_t mpp, Double_t mr) const
{
  Double_t c(0);
  
  //  double pi=TMath::Pi();
  // double deg2rad = pi/180.;
  
  Double_t J = Spin;
  int LB = (int)(J-0.5);
  if(LB<0) LB = 0;

  double pB = getp(m_lb, m_k, mpp);
  double pB0 = pB;
  if(mr>1e-10&&mr+m_k<m_lb) pB0 = getp(m_lb, m_k, mr);
  
  //  double phi00 = ((RooAbsReal&)ires[ihel*2+1]).getVal()*deg2rad;
  c = F_BW(_FFB,LB,pB,pB0) * pow(pB/m_lb, LB);
  // if(h3<0) //lamda_3 <0 /\->pK strong decay???
  //
  
  return c;
  
}



////////////////////////////////////////////////
//   Breit Wigner Resonance
////////////////////////////////////////////////
void RooDalitzAmplitude::breit_wigner(double m, double gamma, double e2, double &r_ampl, double &i_ampl) const
{
  double de2 = m*m-e2;
  double gamma_m = gamma*m;
  double d = (de2*de2+gamma_m*gamma_m);
  r_ampl = de2/d;
  i_ampl = gamma_m/d;
}
/////////////////////////////////////////////
//Blatt-Weisskopf form factors
/////////////////////////////////////////////
Double_t RooDalitzAmplitude::F_BW(double r, int L, double p, double p0) const
{
  double z = pow(r*p,2);
  double z0 = pow(r*p0,2);
  if(L==0) return 1.0;
  if(L==1) return sqrt((1.+z0)/(1.+z));
  if(L==2) return sqrt((z0*z0+3*z0+9.)/(z*z+3*z+9.));
  if(L==3) return sqrt((z0*z0*z0+6*z0*z0+45*z0+225)/(z*z*z+6*z*z+45*z+225));
  if(L==4) return sqrt((pow(z0,4)+10*pow(z0,3)+135*z0*z0+1575*z0+11025)
                         /(pow(z,4)+10*pow(z,3)+135*z*z+1575*z+11025));
  if(L==5) return sqrt((pow(z0,5)+15*pow(z0,4)+315*pow(z0,3)+6300*pow(z0,2)+99225*z0+893025)
                    /(pow(z,5)+15*pow(z,4)+315*pow(z,3)+6300*pow(z,2)+99225*z+893025));
  
  return 1.0;
}//////////////////////////////////////////////////
// Breit Wigner Amplitude
/////////////////////////////////////////////////
bool RooDalitzAmplitude::BW_AMP(double m_r, double gamma_r, double mpp, int LR,
                             double &ampl_r, double &ampl_i) const
{
  ampl_r = 0;
  ampl_i = 0;
  double m2pp = mpp*mpp;
//  if(J>2) return false;
 // if(abs(helz)>1) return false;
 // if(J==0&&abs(helz)!=0) return true;
  //  int LB = 1;
  //int LR = (J-0.5);
  // if(J==1) {
  //  LB = 0; //changed by LM
  //} else if(J==2) {
  //  LB = 1; //changed by LM
  //}
  //double pB = getpB(mpp);
  double pR = getp(mpp, m_p, m_k);
  //For NR
  if(m_r<-500) {
    ampl_r = pow(pR,LR);
    ampl_i = 0;
    return true;
  }
  double pR0=pR;
  if(m_r>m_p+m_k) pR0 = getp(m_r, m_p, m_k);//sqrt(m_r*m_r-4*m2_pi)/2.;
  
  //double FB = F_BW(_FFB,LB,pB,pB0);
  double FR = F_BW(_FFR,LR,pR,pR0);
//  cout << "_FFR " << _FFR << endl;

  double bw_r(0),bw_i(0);
  double gamma = gamma_r;
  //if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  if(m_r>m_p+m_k)  {gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR; }
  else if(m_r<1.43&&m_r>0) {
  /*
    //where LR = 0
    double msig = 1.192642;
    double mpi0 = 0.1349766;
    double pRSigPi = getp(mpp, msig, mpi0);
    double rhosigpi = 2.0*pRSigPi/mpp;
    double rhokp = 2.0*pR/mpp;
    gamma = gamma_r * (rhosigpi+rhokp)*9.0645/2.;
//    std::cout << "gamma_r " << gamma_r << " " << gamma << std::endl; 
*/
    double msig = 1.18937;//1.192642;
    double mpi0 = 0.13957018;//0.1349766;
    double pRSigPi = getp(mpp, msig, mpi0);
//    double rhosigpi = 2.0*pRSigPi/mpp;
//    double rhokp = 2.0*pR/mpp;
    //mine
//    gamma = gamma_r * (rhosigpi+rhokp)*m_r/2./getp(m_r,msig,mpi0);//9.0645/2.;

    //wehre LR = 0;
    gamma = 0.0;
    pR0 = getp(m_r,msig,mpi0);
    FR = 1.0;//F_BW(_FFR,LR,pR,pR0);
    gamma += gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
    FR = 1.0;//F_BW(_FFR,LR,pRSigPi,pR0);
    gamma += 0.0505*pow((pRSigPi/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  }

  breit_wigner(m_r, gamma, m2pp, bw_r, bw_i);
  
  //charged 4/17 mpp->mr
//  double factor = FR*pow(pR/mpp,LR);
  double factor = FR*pow(pR/m_r,LR);  
  ampl_r = factor*bw_r;
  ampl_i = factor*bw_i;
  return true;
}

bool RooDalitzAmplitude::BW_AMPZ(double m_r, double gamma_r, double mpp, int LR,
                             double &ampl_r, double &ampl_i) const
{
  ampl_r = 0;
  ampl_i = 0;
  double m2pp = mpp*mpp;
//  if(J>2) return false;
 // if(abs(helz)>1) return false;
 // if(J==0&&abs(helz)!=0) return true;
  //  int LB = 1;
  //int LR = (J-0.5);
  // if(J==1) {
  //  LB = 0; //changed by LM
  //} else if(J==2) {
  //  LB = 1; //changed by LM
  //}
  //double pB = getpB(mpp);
  double pR = getp(mpp, m_p, m_jpsi);
  double pR0=pR;
  if(m_r>m_p+m_jpsi) pR0 = getp(m_r, m_p, m_jpsi);//sqrt(m_r*m_r-4*m2_pi)/2.;
  
  //double FB = F_BW(_FFB,LB,pB,pB0);
  double FR = F_BW(_FFR,LR,pR,pR0);
//  cout << "_FFR " << _FFR << endl;

  double bw_r(0),bw_i(0);
  double gamma = gamma_r;
  //if(with_dep!=0) gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  if(m_r>m_p+m_jpsi)  gamma = gamma_r*pow((pR/pR0),2*LR+1)*(m_r/mpp)*FR*FR;
  breit_wigner(m_r, gamma, m2pp, bw_r, bw_i);
//charged mpp->mr
//  double factor = FR*pow(pR/mpp,LR);
  double factor = FR*pow(pR/m_r,LR);  
  ampl_r = factor*bw_r;
  ampl_i = factor*bw_i;
  return true;
}

Double_t RooDalitzAmplitude::getp(double M, double m1, double m2) const
{
  double M2 = M*M;
  if(M<m1+m2) std::cout << "why M<m1+m2" << std::endl;
  return sqrt((M2-pow(m1+m2,2))*(M2-pow(m1-m2,2)))/2./M;
}


Double_t RooDalitzAmplitude::getphsp(double mX) const
{
  return getp(m_lb, m_jpsi, mX)*getp(mX, m_p, m_k);
}

void RooDalitzAmplitude::filldlz(Jpsihh_dlz &dlz, Double_t xmkp, Double_t xcostheta,
                                 Double_t xcostheta1, Double_t xcostheta2,
                                 Double_t xphi1, Double_t xphi2, 
				 Double_t xcosthetaB, Double_t xcosthetaZ, Double_t xcosthetaPsi,
				 Double_t xphiZ, Double_t xphiPsi, Double_t xphiMu, 
				 Double_t xcosthetap, Double_t xalphaMu,
				 Double_t xmjpsip,
				 Double_t sw) const
{
  dlz.mkp = xmkp; 
  dlz.mjpsip = xmjpsip;
  dlz.theta = acos(xcostheta);
  dlz.theta1 = acos(xcostheta1);
  dlz.theta2 = acos(xcostheta2);
  dlz.phi1 = xphi1;
  dlz.phi2 = xphi2;

  dlz.thetaB = acos(xcosthetaB);
  dlz.thetaZ = acos(xcosthetaZ);
  dlz.thetaPsi = acos(xcosthetaPsi);
  dlz.phiZ = xphiZ;
  dlz.phiPsi = xphiPsi;
  dlz.phiMu = xphiMu;
  dlz.thetap = acos(xcosthetap);
  dlz.alphaMu = xalphaMu;

//  dlz.phi = xphi;

  dlz.w = sw;
  
  int nres = NR+NZ;
  for(int ir=0; ir<nres; ++ir) {
    dlz.defed[ir] = false;
  }/*
    for(int i=0;i<=1; ++i) {
      for(int j=0; j<=1; ++j) {
	for(int k=0; k<=1; ++k) {
	  for(int m=0; m<6; ++m) {
	    dlz.ARe[ir][i][j][k][m] = 0.0;
	    dlz.AIm[ir][i][j][k][m] = 0.0;
	  }
	}
	}
    }
  }*/

}

//_____________________________________________________________________________
RooAbsReal*  RooDalitzAmplitude::createSUM(RooAbsData& data, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, 
                                             const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) 
{
  // Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset
  // is binned, a binned likelihood is constructed. 
  //
  // The following named arguments are supported
  //
  // ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables
  // Extended(Bool_t flag)           -- Add extended likelihood term, off by default
  // Range(const char* name)         -- Fit only data inside range with given name
  // Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named "fit" is created on the fly on all observables.
  //                                    Multiple comma separated range names can be specified.
  // SumCoefRange(const char* name)  -- Set the range in which to interpret the coefficients of RooAddPdf components  
  // NumCPU(int num, int strat)      -- Parallelize NLL calculation on num CPUs
  //
  //                                    Strategy 0 = RooFit::BulkPartition (Default) --> Divide events in N equal chunks 
  //                                    Strategy 1 = RooFit::Interleave --> Process event i%N in process N. Recommended for binned data with 
  //                                                 a substantial number of zero-bins, which will be distributed across processes more equitably in this strategy
  //                                    Strategy 2 = RooFit::SimComponents --> Process each component likelihood of a RooSimultaneous fully in a single process
  //                                                 and distribute components over processes. This approach can be benificial if normalization calculation time
  //                                                 dominates the total computation time of a component (since the normalization calculation must be performed
  //                                                 in each process in strategies 0 and 1. However beware that if the RooSimultaneous components do not share many
  //                                                 parameters this strategy is inefficient: as most minuit-induced likelihood calculations involve changing
  //                                                 a single parameter, only 1 of the N processes will be active most of the time if RooSimultaneous components
  //                                                 do not share many parameters
  //                                    Strategy 3 = RooFit::Hybrid --> Follow strategy 0 for all RooSimultaneous components, except those with less than
  //                                                 30 dataset entries, for which strategy 2 is followed.
  //
  // Optimize(Bool_t flag)           -- Activate constant term optimization (on by default)
  // SplitRange(Bool_t flag)         -- Use separate fit ranges in a simultaneous fit. Actual range name for each
  //                                    subsample is assumed to by rangeName_{indexState} where indexState
  //                                    is the state of the master index category of the simultaneous fit
  // Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters
  // ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood
  // GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.
  //                                        If none are specified the constrained parameters are used
  // GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute
  //                                              associated with pdf observables that match the given tagName 
  // Verbose(Bool_t flag)           -- Constrols RooFit informational messages in likelihood construction
  // CloneData(Bool flag)           -- Use clone of dataset in SUM (default is true)
  // Offset(Bool_t)                  -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This
  //                                    can improve numeric stability in simultaneously fits with components with large likelihood values
  // 
  // 
  
  RooLinkedList l ;
  l.Add((TObject*)&arg1) ;  l.Add((TObject*)&arg2) ;  
  l.Add((TObject*)&arg3) ;  l.Add((TObject*)&arg4) ;
  l.Add((TObject*)&arg5) ;  l.Add((TObject*)&arg6) ;  
  l.Add((TObject*)&arg7) ;  l.Add((TObject*)&arg8) ;
  return createSUM(data,l) ;
}




//_____________________________________________________________________________
RooAbsReal*  RooDalitzAmplitude::createSUM(RooAbsData& data, const RooLinkedList& cmdList) 
{
  // Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset
  // is binned, a binned likelihood is constructed. 
  //
  // See RooAbsPdf::createSUM(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4, 
  //                                    RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8) 
  //
  // for documentation of options


  // Select the pdf-specific commands 
  RooCmdConfig pc(Form("RooAbsPdf::createSUM(%s)",GetName())) ;

  pc.defineString("rangeName","RangeWithName",0,"",kTRUE) ;
  pc.defineString("addCoefRange","SumCoefRange",0,"") ;
  pc.defineString("globstag","GlobalObservablesTag",0,"") ;
  pc.defineDouble("rangeLo","Range",0,-999.) ;
  pc.defineDouble("rangeHi","Range",1,-999.) ;
  pc.defineInt("splitRange","SplitRange",0,0) ;
  pc.defineInt("ext","Extended",0,2) ;
  pc.defineInt("numcpu","NumCPU",0,1) ;
  pc.defineInt("interleave","NumCPU",1,0) ;
  pc.defineInt("verbose","Verbose",0,0) ;
  pc.defineInt("optConst","Optimize",0,0) ;
  pc.defineInt("cloneData","CloneData",2,0) ;
  pc.defineSet("projDepSet","ProjectedObservables",0,0) ;
  pc.defineSet("cPars","Constrain",0,0) ;
  pc.defineSet("glObs","GlobalObservables",0,0) ;
  pc.defineInt("constrAll","Constrained",0,0) ;
  pc.defineInt("doOffset","OffsetLikelihood",0,0) ;
  pc.defineSet("extCons","ExternalConstraints",0,0) ;
  pc.defineMutex("Range","RangeWithName") ;
  pc.defineMutex("Constrain","Constrained") ;
  pc.defineMutex("GlobalObservables","GlobalObservablesTag") ;
    
  // Process and check varargs 
  pc.process(cmdList) ;
  if (!pc.ok(kTRUE)) {
    return 0 ;
  }

  // Decode command line arguments
  const char* rangeName = pc.getString("rangeName",0,kTRUE) ;
  const char* addCoefRangeName = pc.getString("addCoefRange",0,kTRUE) ;
  const char* globsTag = pc.getString("globstag",0,kTRUE) ;
  Int_t ext      = pc.getInt("ext") ;
  Int_t numcpu   = pc.getInt("numcpu") ;
  RooFit::MPSplit interl = (RooFit::MPSplit) pc.getInt("interleave") ;

  Int_t splitr   = pc.getInt("splitRange") ;
  Bool_t verbose = pc.getInt("verbose") ;
  Int_t optConst = pc.getInt("optConst") ;
  Int_t cloneData = pc.getInt("cloneData") ;
  Int_t doOffset = pc.getInt("doOffset") ;
  
  // If no explicit cloneData command is specified, cloneData is set to true if optimization is activated
  if (cloneData==2) {
    cloneData = optConst ;
  }


  RooArgSet* cPars = pc.getSet("cPars") ;
  RooArgSet* glObs = pc.getSet("glObs") ;
  if (pc.hasProcessed("GlobalObservablesTag")) {
    if (glObs) delete glObs ;
    RooArgSet* allVars = getVariables() ;
    glObs = (RooArgSet*) allVars->selectByAttrib(globsTag,kTRUE) ;
//    coutI(Minimization) << "User-defined specification of global observables definition with tag named '" <<  globsTag << "'" << endl ;
    delete allVars ;
  } else if (!pc.hasProcessed("GlobalObservables")) {

    // Neither GlobalObservables nor GlobalObservablesTag has been processed - try if a default tag is defined in the head node
    // Check if head not specifies default global observable tag
    const char* defGlobObsTag = getStringAttribute("DefaultGlobalObservablesTag") ;
    if (defGlobObsTag) {
      coutI(Minimization) << "p.d.f. provides built-in specification of global observables definition with tag named '" <<  defGlobObsTag << "'" << std::endl ;
      if (glObs) delete glObs ;
      RooArgSet* allVars = getVariables() ;
      glObs = (RooArgSet*) allVars->selectByAttrib(defGlobObsTag,kTRUE) ;
    }
  }
  
    
  Bool_t doStripDisconnected=kFALSE ;

  // If no explicit list of parameters to be constrained is specified apply default algorithm
  // All terms of RooProdPdfs that do not contain observables and share a parameters with one or more
  // terms that do contain observables are added as constraints.
  if (!cPars) {    
    cPars = getParameters(data,kFALSE) ;
    doStripDisconnected=kTRUE ;
  }
  const RooArgSet* extCons = pc.getSet("extCons") ;

  // Process automatic extended option
  if (ext==2) {
    ext = ((extendMode()==CanBeExtended || extendMode()==MustBeExtended)) ? 1 : 0 ;
    if (ext) {
      coutI(Minimization) << "p.d.f. provides expected number of events, including extended term in likelihood." << std::endl ;
    }
  }

  if (pc.hasProcessed("Range")) {
    Double_t rangeLo = pc.getDouble("rangeLo") ;
    Double_t rangeHi = pc.getDouble("rangeHi") ;
   
    // Create range with name 'fit' with above limits on all observables
    RooArgSet* obs = getObservables(&data) ;
    TIterator* iter = obs->createIterator() ;
    RooAbsArg* arg ;
    while((arg=(RooAbsArg*)iter->Next())) {
      RooRealVar* rrv =  dynamic_cast<RooRealVar*>(arg) ;
      if (rrv) rrv->setRange("fit",rangeLo,rangeHi) ;
    }
    // Set range name to be fitted to "fit"
    rangeName = "fit" ;
  }

  RooArgSet projDeps ;
  RooArgSet* tmp = pc.getSet("projDepSet") ;  
  if (tmp) {
    projDeps.add(*tmp) ;
  }

  // Construct SUM
  RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::CollectErrors) ;
  RooAbsReal* nll ;
  std::string baseName = Form("sum_%s_%s",GetName(),data.GetName()) ;
  if (!rangeName || strchr(rangeName,',')==0) {
    // Simple case: default range, or single restricted range
    //cout<<"FK: Data test 1: "<<data.sumEntries()<<std::std::endl;

    nll = new RooSUMVar(baseName.c_str(),"sum(likelihood)",*this,data,projDeps,ext,rangeName,addCoefRangeName,numcpu,interl,verbose,splitr,cloneData) ;

  } else {
    // Composite case: multiple ranges
    RooArgList nllList ;
    const size_t bufSize = strlen(rangeName)+1;
    char* buf = new char[bufSize] ;
    strlcpy(buf,rangeName,bufSize) ;
    char* token = strtok(buf,",") ;
    while(token) {
      RooAbsReal* nllComp = new RooSUMVar(Form("%s_%s",baseName.c_str(),token),"-log(likelihood)",*this,data,projDeps,ext,token,addCoefRangeName,numcpu,interl,verbose,splitr,cloneData) ;
      nllList.add(*nllComp) ;
      token = strtok(0,",") ;
    }
    delete[] buf ;
    nll = new RooAddition(baseName.c_str(),"sum(likelihood)",nllList,kTRUE) ;
  }
  RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::PrintErrors) ;
  
  // Collect internal and external constraint specifications
  RooArgSet allConstraints ;
  if (cPars && cPars->getSize()>0) {
    RooArgSet* constraints = getAllConstraints(*data.get(),*cPars,doStripDisconnected) ;
    allConstraints.add(*constraints) ;
    delete constraints ;
    
  }
  if (extCons) {
    allConstraints.add(*extCons) ;
  }

/*  // Include constraints, if any, in likelihood
  RooAbsReal* nllCons(0) ;
  if (allConstraints.getSize()>0 && cPars) {   

    coutI(Minimization) << " Including the following contraint terms in minimization: " << allConstraints << std::endl ;
    if (glObs) {
      coutI(Minimization) << "The following global observables have been defined: " << *glObs << std::endl ;
    }
    nllCons = new RooConstraintSum(Form("%s_constr",baseName.c_str()),"nllCons",allConstraints,glObs ? *glObs : *cPars) ;
    nllCons->setOperMode(ADirty) ;
    RooAbsReal* orignll = nll ;

    nll = new RooAddition(Form("%s_with_constr",baseName.c_str()),"nllWithCons",RooArgSet(*nll,*nllCons)) ;
    nll->addOwnedComponents(RooArgSet(*orignll,*nllCons)) ;
  }

  */
  if (optConst) {
    nll->constOptimizeTestStatistic(RooAbsArg::Activate,optConst>1) ;
  }

  if (doStripDisconnected) {
    delete cPars ;
  }

  if (doOffset) {
    nll->enableOffsetting(kTRUE) ;
  }

  return nll ;
}





/*
Double_t RooDalitzAmplitude::getpB(double mpp) const
{
  return sqrt((m2_bs-(m_jpsi+mpp)*(m_jpsi+mpp))*(m2_bs-(m_jpsi-mpp)*(m_jpsi-mpp)))/2./m_bs;
}

Double_t RooDalitzAmplitude::getpR(double mpp) const
{
  return sqrt(mpp*mpp-4*m2_pi)/2.;
}
*/
